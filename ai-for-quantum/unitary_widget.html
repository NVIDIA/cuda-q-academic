<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Unitary Widget</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1A1A1A;
            color: #E0E0E0;
        }
        .nvidia-green { color: #76B900; }
        .gate-btn {
            background-color: #2A2A2A;
            border: 1px solid #444;
            color: #E0E0E0;
            transition: all 0.2s ease-in-out;
        }
        .gate-btn:hover {
            background-color: #76B900;
            color: #1A1A1A;
            border-color: #76B900;
        }
        .info-box {
            background-color: #2A2A2A;
            border-radius: 0.5rem;
            border: 1px solid #444;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        .matrix-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            justify-items: center;
            align-items: center;
            border-left: 2px solid #666;
            border-right: 2px solid #666;
            border-radius: 10px;
            padding: 0.5rem;
        }
        .legend-dot {
            height: 0.8rem;
            width: 0.8rem;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.4rem;
            vertical-align: middle;
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto p-4 max-w-7xl">
        <header class="text-center mb-4">
            <h1 class="text-2xl font-bold nvidia-green">Quantum Unitary Matching</h1>
            <p class="text-gray-400 mt-1 text-sm max-w-2xl mx-auto">
                Your goal is to match the target unitary transformation shown on the Bloch spheres.
            </p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <div class="space-y-4">
                <div class="info-box p-2 text-center">
                    <h3 class="text-md font-semibold mb-1">Unitary Infidelity</h3>
                    <p class="text-2xl font-bold font-mono nvidia-green" id="deviation-display">0.00000</p>
                </div>
                <div class="info-box p-2">
                     <h3 class="text-md font-semibold text-center mb-1 nvidia-green">Target Unitary</h3>
                    <div id="target-matrix-display" class="font-mono text-sm"></div>
                </div>
                 <div class="info-box p-2">
                    <h3 class="text-md font-semibold text-center mb-1 text-white">Your Unitary</h3>
                    <div id="user-matrix-display" class="font-mono text-sm"></div>
                </div>
            </div>

            <div class="space-y-4">
                 <div class="info-box p-3">
                    <h3 class="text-md font-semibold text-center mb-2">Apply Quantum Gates</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="X">X</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Rotates 180° about the X-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="Y">Y</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Rotates 180° about the Y-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="Z">Z</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Rotates 180° about the Z-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="H">H</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Hadamard: Rotates around a tilted axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="S">S</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Phase Gate: Rotates 90° about Z-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="T">T</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">T Gate: Rotates 45° about Z-axis</span>
                        </div>
                    </div>
                    <button id="reset-circuit-btn" class="gate-btn w-full p-2 mt-2 rounded-md font-semibold">Reset Circuit</button>
                    <button id="undo-gate-btn" class="gate-btn w-full p-2 mt-2 rounded-md font-semibold">Undo Last Gate</button>
                </div>
                <div class="info-box p-2">
                    <h3 class="text-md font-semibold text-center mb-1 text-white">Your Circuit's Gate Sequence</h3>
                    <div id="gate-sequence-display" class="font-mono text-center text-sm bg-gray-900 rounded break-words min-h-[2.5rem] flex items-center justify-center p-1"></div>
                </div>
            </div>

            <div class="space-y-4">
                <div>
                    <h2 class="text-lg font-semibold text-center mb-1">Action on |0⟩ State</h2>
                    <div id="sphere-0" class="w-full h-72 rounded-lg overflow-hidden info-box p-0"></div>
                </div>
                <div>
                    <h2 class="text-lg font-semibold text-center mb-1">Action on |1⟩ State</h2>
                    <div id="sphere-1" class="w-full h-72 rounded-lg overflow-hidden info-box p-0"></div>
                </div>
                <div class="flex justify-center items-center space-x-4 text-sm pt-2">
                    <div class="flex items-center"><span class="legend-dot" style="background-color: #76B900;"></span>Target</div>
                    <div class="flex items-center"><span class="legend-dot" style="background-color: #FFFFFF;"></span>Your Circuit</div>
                </div>
            </div>
        </div>

        <div class="info-box p-4 mt-6">
            <h3 class="text-lg font-bold text-center mb-3">Instructions & Details</h3>
            <div class="text-sm text-gray-300 space-y-2">
                <p>
                    Your goal is to match the target unitary transformation. Apply quantum gates to create a circuit that gets as close as possible to the target's action on the |0⟩ and |1⟩ states.
                </p>
                <p>
                    The <b>Bloch spheres</b> show the result: the <b>green vector</b> is the target and the <b>white vector</b> is your circuit's state. Drag the spheres to view them from different angles.
                </p>
                <p>
                    The <b>Unitary Infidelity</b> score (lower is better, 0.0 is a perfect match) is calculated using the formula:
                </p>
                <code class="bg-gray-900 p-2 rounded-md block mt-2 text-center nvidia-green font-mono">
                    1 - |Tr(U<sub>target</sub>&dagger; &middot; U<sub>circuit</sub>) / 2|<sup>2</sup>
                </code>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Complex Number & Matrix Helpers ---
        const complex = (re = 0, im = 0) => ({ re, im });
        const cadd = (a, b) => complex(a.re + b.re, a.im + b.im);
        const cmul = (a, b) => complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
        const cconj = (a) => complex(a.re, -a.im);
        const cabs_sq = (a) => a.re * a.re + a.im * a.im;

        const matrixMultiply = (A, B) => {
            const C = [[complex(), complex()], [complex(), complex()]];
            C[0][0] = cadd(cmul(A[0][0], B[0][0]), cmul(A[0][1], B[1][0]));
            C[0][1] = cadd(cmul(A[0][0], B[0][1]), cmul(A[0][1], B[1][1]));
            C[1][0] = cadd(cmul(A[1][0], B[0][0]), cmul(A[1][1], B[1][0]));
            C[1][1] = cadd(cmul(A[1][0], B[0][1]), cmul(A[1][1], B[1][1]));
            return C;
        };
        const matrixAdjoint = (A) => [[cconj(A[0][0]), cconj(A[1][0])], [cconj(A[0][1]), cconj(A[1][1])]];
        const matrixTrace = (A) => cadd(A[0][0], A[1][1]);

        // --- Quantum State & Gates ---
        let targetUnitary, userUnitary, gateSequence;
        const state0 = { alpha: complex(1), beta: complex(0) };
        const state1 = { alpha: complex(0), beta: complex(1) };
        
        const GATES = {
            X: [[complex(0), complex(1)], [complex(1), complex(0)]],
            Y: [[complex(0), complex(0, -1)], [complex(0, 1), complex(0)]],
            Z: [[complex(1), complex(0)], [complex(0), complex(-1)]],
            H: [[complex(1/Math.sqrt(2)), complex(1/Math.sqrt(2))], [complex(1/Math.sqrt(2)), complex(-1/Math.sqrt(2))]],
            S: [[complex(1), complex(0)], [complex(0), complex(0, 1)]],
            T: [[complex(1), complex(0)], [complex(0), complex(Math.cos(Math.PI/4), Math.sin(Math.PI/4))]],
        };

        function applyUnitaryToState(unitaryMatrix, state) {
            const { alpha: alpha_in, beta: beta_in } = state;
            const alpha_out = cadd(cmul(unitaryMatrix[0][0], alpha_in), cmul(unitaryMatrix[0][1], beta_in));
            const beta_out = cadd(cmul(unitaryMatrix[1][0], alpha_in), cmul(unitaryMatrix[1][1], beta_in));
            return { alpha: alpha_out, beta: beta_out };
        }
        
        function stateToBloch(state) {
            const alpha_mag_sq = cabs_sq(state.alpha);
            const clamped_alpha_mag = Math.max(0, Math.min(1, Math.sqrt(alpha_mag_sq)));
            const theta = 2 * Math.acos(clamped_alpha_mag);
            let phi_beta = Math.atan2(state.beta.im, state.beta.re);
            let phi_alpha = Math.atan2(state.alpha.im, state.alpha.re);
            const phi = phi_beta - phi_alpha;
            return { theta, phi };
        }

        // --- Core Logic & Display ---
        function getFixedTargetUnitary() {
            const u = [[complex(0.567, -0.234), complex(-0.345, 0.678)], [complex(0.789, 0.123),  complex(0.456, -0.567)]];
            const det = cadd(cmul(u[0][0], u[1][1]), cmul(complex(-1), cmul(u[0][1], u[1][0])));
            const norm = Math.sqrt(cabs_sq(det));
            return [[complex(u[0][0].re/norm, u[0][0].im/norm), complex(u[0][1].re/norm, u[0][1].im/norm)], [complex(u[1][0].re/norm, u[1][0].im/norm), complex(u[1][1].re/norm, u[1][1].im/norm)]];
        }

        function calculateUnitaryDeviation() {
            const product = matrixMultiply(matrixAdjoint(targetUnitary), userUnitary);
            const trace = matrixTrace(product);
            const fidelity = cabs_sq(complex(trace.re / 2, trace.im / 2));
            const infidelity = 1.0 - fidelity;

            const displayEl = document.getElementById('deviation-display');
            displayEl.textContent = infidelity.toFixed(5);
            displayEl.classList.toggle('text-green-300', infidelity < 0.0001);
            displayEl.classList.toggle('nvidia-green', infidelity >= 0.0001);
        }

        function formatComplexForMatrix(c) {
            const re = c.re.toFixed(2);
            const im = c.im.toFixed(2);
            if (Math.abs(c.im) < 1e-3) return `${re}`;
            if (Math.abs(c.re) < 1e-3) return `${im}j`;
            return `${re}${c.im >= 0 ? '+' : ''}${im}j`;
        }

        function displayMatrix(elementId, matrix) {
            const container = document.getElementById(elementId);
            if (!container.classList.contains('matrix-container')) {
                 container.classList.add('matrix-container');
            }
            const [ [c00, c01], [c10, c11] ] = matrix;
            container.innerHTML = `
                <span>${formatComplexForMatrix(c00)}</span><span>${formatComplexForMatrix(c01)}</span>
                <span>${formatComplexForMatrix(c10)}</span><span>${formatComplexForMatrix(c11)}</span>`;
        }
        
        function updateGateSequenceDisplay() {
            const displayEl = document.getElementById('gate-sequence-display');
            displayEl.innerHTML = gateSequence.length === 0 
                ? '<span class="text-gray-500">Empty</span>' 
                : gateSequence.join(' ');
        }
        
        function recalculateUserUnitary() {
            userUnitary = [[complex(1), complex(0)], [complex(0), complex(1)]];
            for (const gateName of gateSequence) {
                const gateMatrix = GATES[gateName];
                userUnitary = matrixMultiply(gateMatrix, userUnitary);
            }
        }
        
        function createBlochSphere(container) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3.5);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.minDistance = 2.5;
            controls.maxDistance = 8;

            const group = new THREE.Group();
            scene.add(group);

            const sphereGeom = new THREE.SphereGeometry(1, 24, 24);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.15, wireframe: true });
            group.add(new THREE.Mesh(sphereGeom, sphereMat));

            const targetVector = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 1, 0x76B900, 0.15, 0.08);
            group.add(targetVector);

            const userVector = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 1, 0xFFFFFF, 0.15, 0.08);
            group.add(userVector);

            const createLabel = (text, position, fontSize = 32) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                context.font = `Bold ${fontSize}px Inter`;
                canvas.width = context.measureText(text).width + 20;
                canvas.height = fontSize * 1.5;
                context.font = `Bold ${fontSize}px Inter`;
                context.fillStyle = "rgba(224, 224, 224, 0.95)";
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.scale.set(canvas.width / 150, canvas.height / 150, 1.0);
                sprite.position.copy(position);
                return sprite;
            };

            group.add(createLabel('|0⟩', new THREE.Vector3(0, 1.15, 0), 32));
            group.add(createLabel('|1⟩', new THREE.Vector3(0, -1.15, 0), 32));
            const axisFontSize = 28;
            group.add(createLabel('|+⟩', new THREE.Vector3(1.15, 0, 0), axisFontSize));
            group.add(createLabel('|-⟩', new THREE.Vector3(-1.15, 0, 0), axisFontSize));
            group.add(createLabel('|+i⟩', new THREE.Vector3(0, 0, 1.15), axisFontSize));
            group.add(createLabel('|-i⟩', new THREE.Vector3(0, 0, -1.15), axisFontSize));

            const onWindowResize = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };
            window.addEventListener('resize', onWindowResize);

            return { scene, camera, renderer, controls, targetVector, userVector, onWindowResize };
        }

        function updateVectorPosition(vector, state) {
            const { theta, phi } = stateToBloch(state);
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.cos(theta);
            const z = Math.sin(theta) * Math.sin(phi);
            vector.setDirection(new THREE.Vector3(x, y, z).normalize());
        }

        const viz = {
            sphere0: createBlochSphere(document.getElementById('sphere-0')),
            sphere1: createBlochSphere(document.getElementById('sphere-1')),
        };

        function updateAllVisuals() {
            const targetState0 = applyUnitaryToState(targetUnitary, state0);
            const targetState1 = applyUnitaryToState(targetUnitary, state1);
            const userState0 = applyUnitaryToState(userUnitary, state0);
            const userState1 = applyUnitaryToState(userUnitary, state1);

            updateVectorPosition(viz.sphere0.targetVector, targetState0);
            updateVectorPosition(viz.sphere0.userVector, userState0);
            
            updateVectorPosition(viz.sphere1.targetVector, targetState1);
            updateVectorPosition(viz.sphere1.userVector, userState1);
            
            displayMatrix('target-matrix-display', targetUnitary);
            displayMatrix('user-matrix-display', userUnitary);
            calculateUnitaryDeviation();
            updateGateSequenceDisplay();
        }
        
        function resetCircuit() {
            gateSequence = [];
            recalculateUserUnitary();
            updateAllVisuals();
        }

        function initializeChallenge() {
            targetUnitary = getFixedTargetUnitary();
            resetCircuit();
        }

        function animate() {
            requestAnimationFrame(animate);
            Object.values(viz).forEach(v => {
                v.controls.update();
                v.renderer.render(v.scene, v.camera);
            });
        }

        document.querySelectorAll('.gate-btn[data-gate]').forEach(button => {
            button.addEventListener('click', () => {
                gateSequence.push(button.dataset.gate);
                recalculateUserUnitary();
                updateAllVisuals();
            });
        });
        
        document.getElementById('reset-circuit-btn').addEventListener('click', resetCircuit);

        document.getElementById('undo-gate-btn').addEventListener('click', () => {
            if (gateSequence.length > 0) {
                gateSequence.pop();
                recalculateUserUnitary();
                updateAllVisuals();
            }
        });
        
        initializeChallenge();
        animate();
        
        setTimeout(() => {
            Object.values(viz).forEach(v => v.onWindowResize());
        }, 100);

    </script>
</body>
</html>
