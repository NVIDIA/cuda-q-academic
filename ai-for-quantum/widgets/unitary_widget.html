<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Unitary Widget</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --nvidia-green: #76b900;
            --nvidia-green-dark: #5e9400;
            --nvidia-dark: #1A1A1A;
            --nvidia-mid: #2A2A2A;
            --nvidia-accent: #444444;
            --nvidia-light: #E0E0E0;
            --nvidia-gray: #AAAAAA;
        }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: var(--nvidia-dark); color: var(--nvidia-light); }
        .widget-container {
            background-color: var(--nvidia-mid);
            border: 1px solid var(--nvidia-accent);
            border-top: 4px solid var(--nvidia-green);
            border-radius: 8px;
            padding: 24px;
            width: 100%;
            max-width: 1100px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            margin: 0 auto;
        }
        @media (min-width: 768px) { .widget-container { padding: 32px; } }
        .widget-container h1 {
            color: var(--nvidia-green);
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
            margin-top: 0;
            font-weight: 700;
            line-height: 1.2;
        }
        .widget-container .summary-text { color: var(--nvidia-gray); margin-bottom: 8px; font-size: 1rem; line-height: 1.5; }
        .instructions-section {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--nvidia-accent);
            border-radius: 8px;
        }
        .instructions-section h2 { color: var(--nvidia-green); font-size: 1.1rem; margin: 0 0 12px 0; font-weight: 700; }
        .instructions-section ol, .instructions-section p { color: var(--nvidia-light); font-size: 0.95rem; line-height: 1.5; margin: 0 0 8px 0; }
        .instructions-section .kbd { background: var(--nvidia-accent); padding: 2px 6px; border-radius: 4px; font-family: inherit; font-size: 0.9em; }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--nvidia-green); color: #000; padding: 8px 16px; z-index: 100; text-decoration: none; font-weight: bold; }
        .skip-link:focus { top: 0; }
        .widget-footer { margin-top: 32px; border-top: 1px solid var(--nvidia-accent); padding-top: 16px; text-align: center; }
        .widget-footer-links { display: flex; flex-wrap: wrap; gap: 16px; justify-content: center; align-items: center; }
        .widget-footer-links a { color: #76b900; text-decoration: none; min-height: 44px; padding: 12px 24px; display: inline-flex; align-items: center; justify-content: center; border-radius: 4px; }
        .widget-footer-links a:hover { color: var(--nvidia-light); background: rgba(255,255,255,0.05); }
        .widget-footer-links a:focus { outline: 3px solid var(--nvidia-green); outline-offset: 2px; }
        @media (prefers-reduced-motion: reduce) { *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; } }
        .nvidia-green { color: #76B900; }
        .gate-btn {
            background-color: #2A2A2A;
            border: 1px solid #444;
            color: #E0E0E0;
            transition: all 0.2s ease-in-out;
        }
        .gate-btn:hover {
            background-color: #76B900;
            color: #1A1A1A;
            border-color: #76B900;
        }
        .info-box {
            background-color: #2A2A2A;
            border-radius: 0.5rem;
            border: 1px solid #444;
        }
        .bloch-viewport {
            background-color: #000000;
        }
        .bloch-viewport:focus {
            outline: 4px solid var(--nvidia-green);
            outline-offset: 2px;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        .matrix-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            justify-items: center;
            align-items: center;
            border-left: 2px solid #666;
            border-right: 2px solid #666;
            border-radius: 10px;
            padding: 0.5rem;
        }
        .legend-dot {
            height: 0.8rem;
            width: 0.8rem;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.4rem;
            vertical-align: middle;
        }
        .fidelity-formula {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 1.2rem;
            font-weight: 500;
            color: var(--nvidia-green);
            line-height: 1.4;
        }
    </style>
</head>
<body class="antialiased">
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <div class="widget-container" id="main-content">
        <header>
            <h1>Quantum Unitary Matching</h1>
            <p class="summary-text">Match the target unitary by building a circuit so that your vectors (translucent) align with the target vectors (solid) on the Bloch sphere for |0⟩, |+⟩, and |+i⟩.</p>
        </header>
        <section class="instructions-section" aria-labelledby="instructions-heading">
            <h2 id="instructions-heading">Instructions</h2>
            <ol class="list-decimal list-inside text-gray-300 space-y-1 text-sm">
                <li><strong>Goal:</strong> On the single Bloch sphere, three <strong>solid</strong> arrows show where the <strong>target</strong> unitary sends |0⟩ (green), |+⟩ (cyan), and |+i⟩ (orange). Three <strong>lighter/translucent</strong> arrows show where <strong>your circuit</strong> sends the same states. Match your unitary to the target by applying gates until the translucent arrows align with the solid ones.</li>
                <li>Apply gates (X, Y, Z, H, S, T) so each of your three vectors coincides with its target. Use Reset Circuit or Undo as needed. Your circuit starts as the identity (your arrows begin at the poles).</li>
                <li>Maximize the <strong>Unitary Fidelity</strong> (1.0 = perfect match). When all three pairs of arrows overlap, fidelity is 1.</li>
                <li>Drag the sphere to rotate the view; when focused, use arrow keys to rotate.</li>
            </ol>
            <p><strong>Keyboard:</strong> <span class="kbd">ESC</span> to reset. <span class="kbd">Tab</span> to move between gates and the Bloch sphere. <span class="kbd">Enter</span>/<span class="kbd">Space</span> to activate buttons. When the Bloch sphere is focused, <span class="kbd">←</span><span class="kbd">→</span><span class="kbd">↑</span><span class="kbd">↓</span> rotate the view.</p>
        </section>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <div class="flex flex-col space-y-4">
                <div class="info-box p-2 text-center">
                    <h3 class="text-md font-semibold mb-1">Unitary Fidelity</h3>
                    <p class="text-2xl font-bold font-mono nvidia-green" id="deviation-display">0.00000</p>
                    <p class="fidelity-formula mt-2">|Tr(U<sub>target</sub>† U<sub>circuit</sub>) / 2|<sup>2</sup></p>
                </div>
                <div class="info-box p-2">
                     <h3 class="text-md font-semibold text-center mb-1 nvidia-green">Target Unitary</h3>
                    <div id="target-matrix-display" class="font-mono text-sm"></div>
                </div>
                 <div class="info-box p-2">
                    <h3 class="text-md font-semibold text-center mb-1 text-white">Your Unitary</h3>
                    <div id="user-matrix-display" class="font-mono text-sm"></div>
                </div>
                <div class="info-box p-3">
                    <h3 class="text-md font-semibold text-center mb-2 text-yellow-400">Best Match So Far</h3>
                    <div class="text-sm font-mono">
                        <p>Fidelity: <span id="best-fidelity-display" class="font-bold text-yellow-400">N/A</span></p>
                        <p class="mt-1 break-all">Sequence: <span id="best-sequence-display"></span></p>
                    </div>
                </div>
            </div>

            <div class="space-y-4">
                 <div class="info-box p-3">
                    <h3 class="text-md font-semibold text-center mb-2">Apply Quantum Gates</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="X">X</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Rotates 180° about the X-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="Y">Y</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Rotates 180° about the Y-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="Z">Z</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Rotates 180° about the Z-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="H">H</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Hadamard: Rotates around a tilted axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="S">S</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">Phase Gate: Rotates 90° about Z-axis</span>
                        </div>
                        <div class="relative group">
                            <button class="gate-btn w-full p-2 rounded-md font-bold text-lg" data-gate="T">T</button>
                            <span class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 p-1 px-2 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">T Gate: Rotates 45° about Z-axis</span>
                        </div>
                    </div>
                    <button id="reset-circuit-btn" class="gate-btn w-full p-2 mt-2 rounded-md font-semibold">Reset Circuit</button>
                    <button id="undo-gate-btn" class="gate-btn w-full p-2 mt-2 rounded-md font-semibold">Undo Last Gate</button>
                </div>
                <div class="info-box p-2">
                    <h3 class="text-md font-semibold text-center mb-1 text-white">Your Circuit's Gate Sequence</h3>
                    <div id="gate-sequence-display" class="font-mono text-center text-sm bg-gray-900 rounded break-words min-h-[2.5rem] flex items-center justify-center p-1"></div>
                </div>
            </div>

            <div class="space-y-4">
                <div>
                    <h2 class="text-lg font-semibold text-center mb-1">Target vs. Your Unitary on |0⟩, |+⟩, |+i⟩</h2>
                    <div id="sphere-main" class="bloch-viewport w-full h-80 rounded-lg overflow-hidden p-0" tabindex="0" role="img" aria-label="Bloch sphere: solid vectors = target unitary on |0⟩, |+⟩, |+i⟩; translucent vectors = your circuit. Use arrow keys to rotate when focused."></div>
                </div>
                <div class="flex justify-center gap-8 text-sm pt-2">
                    <div class="flex flex-col items-center gap-1">
                        <div class="flex items-center"><span class="legend-dot" style="background-color: #76B900;"></span>Target</div>
                        <div class="flex items-center"><span class="legend-dot" style="background-color: rgba(118,185,0,0.6); border: 1px solid #76B900;"></span>Your</div>
                        <span class="text-xs mt-0.5 font-semibold">|0⟩</span>
                    </div>
                    <div class="flex flex-col items-center gap-1">
                        <div class="flex items-center"><span class="legend-dot" style="background-color: #00b4d8;"></span>Target</div>
                        <div class="flex items-center"><span class="legend-dot" style="background-color: rgba(0,180,216,0.6); border: 1px solid #00b4d8;"></span>Your</div>
                        <span class="text-xs mt-0.5 font-semibold">|+⟩</span>
                    </div>
                    <div class="flex flex-col items-center gap-1">
                        <div class="flex items-center"><span class="legend-dot" style="background-color: #f4a261;"></span>Target</div>
                        <div class="flex items-center"><span class="legend-dot" style="background-color: rgba(244,162,97,0.6); border: 1px solid #f4a261;"></span>Your</div>
                        <span class="text-xs mt-0.5 font-semibold">|+i⟩</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="lesson-footer" style="margin-top: 32px; font-size: 0.85rem; color: var(--nvidia-gray); text-align: center; border-top: 1px solid var(--nvidia-accent); padding-top: 16px;">
            Note: This widget is part of the CUDA-Q Academic lesson entitled "Compiling Unitaries Using Diffusion Models (AI for Quantum)".
            You can learn more by visiting <a href="https://github.com/NVIDIA/cuda-q-academic/blob/main/ai-for-quantum/01_compiling_unitaries_using_diffusion_models.ipynb" target="_blank" rel="noopener noreferrer" style="color: #76b900;">here</a>.
        </div>
        <footer class="widget-footer" aria-label="Widget and CUDA-Q navigation">
            <div class="widget-footer-links">
                <a href="https://nvidia.github.io/cuda-q-academic/visualization-gallery.html" target="_blank" rel="noopener noreferrer">Back to Visualization Gallery</a>
                <a href="https://github.com/NVIDIA/cuda-q-academic" target="_blank" rel="noopener noreferrer">CUDA-Q Academic</a>
            </div>
        </footer>
    </div>

    <script type="module">
        // --- Complex Number & Matrix Helpers ---
        const complex = (re = 0, im = 0) => ({ re, im });
        const cadd = (a, b) => complex(a.re + b.re, a.im + b.im);
        const cmul = (a, b) => complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
        const cconj = (a) => complex(a.re, -a.im);
        const cabs_sq = (a) => a.re * a.re + a.im * a.im;

        const matrixMultiply = (A, B) => {
            const C = [[complex(), complex()], [complex(), complex()]];
            C[0][0] = cadd(cmul(A[0][0], B[0][0]), cmul(A[0][1], B[1][0]));
            C[0][1] = cadd(cmul(A[0][0], B[0][1]), cmul(A[0][1], B[1][1]));
            C[1][0] = cadd(cmul(A[1][0], B[0][0]), cmul(A[1][1], B[1][0]));
            C[1][1] = cadd(cmul(A[1][0], B[0][1]), cmul(A[1][1], B[1][1]));
            return C;
        };
        const matrixAdjoint = (A) => [[cconj(A[0][0]), cconj(A[1][0])], [cconj(A[0][1]), cconj(A[1][1])]];
        const matrixTrace = (A) => cadd(A[0][0], A[1][1]);

        function isUnitary(A, tol = 1e-10) {
            const I = matrixMultiply(matrixAdjoint(A), A);
            return Math.abs(I[0][0].re - 1) < tol && Math.abs(I[0][0].im) < tol &&
                   Math.abs(I[1][1].re - 1) < tol && Math.abs(I[1][1].im) < tol &&
                   Math.abs(I[0][1].re) < tol && Math.abs(I[0][1].im) < tol &&
                   Math.abs(I[1][0].re) < tol && Math.abs(I[1][0].im) < tol;
        }

        function unitaryFidelity(U_target, U_user) {
            const product = matrixMultiply(matrixAdjoint(U_target), U_user);
            const trace = matrixTrace(product);
            return cabs_sq(complex(trace.re / 2, trace.im / 2));
        }

        // --- Quantum State & Gates ---
        let targetUnitary, userUnitary, gateSequence;
        let bestFidelity, bestGateSequence;

        const inv2 = 1 / Math.sqrt(2);
        const state0 = { alpha: complex(1), beta: complex(0) };           // |0⟩
        const statePlus = { alpha: complex(inv2), beta: complex(inv2) }; // |+⟩ = (|0⟩+|1⟩)/√2
        const stateI = { alpha: complex(inv2), beta: complex(0, inv2) }; // |+i⟩ = (|0⟩+i|1⟩)/√2
        
        const GATES = {
            X: [[complex(0), complex(1)], [complex(1), complex(0)]],
            Y: [[complex(0), complex(0, -1)], [complex(0, 1), complex(0)]],
            Z: [[complex(1), complex(0)], [complex(0), complex(-1)]],
            H: [[complex(1/Math.sqrt(2)), complex(1/Math.sqrt(2))], [complex(1/Math.sqrt(2)), complex(-1/Math.sqrt(2))]],
            S: [[complex(1), complex(0)], [complex(0), complex(0, 1)]],
            T: [[complex(1), complex(0)], [complex(0), complex(Math.cos(Math.PI/4), Math.sin(Math.PI/4))]],
        };

        function applyUnitaryToState(unitaryMatrix, state) {
            const { alpha: alpha_in, beta: beta_in } = state;
            const alpha_out = cadd(cmul(unitaryMatrix[0][0], alpha_in), cmul(unitaryMatrix[0][1], beta_in));
            const beta_out = cadd(cmul(unitaryMatrix[1][0], alpha_in), cmul(unitaryMatrix[1][1], beta_in));
            return { alpha: alpha_out, beta: beta_out };
        }
        
        function stateToBloch(state) {
            const alpha_mag_sq = cabs_sq(state.alpha);
            const clamped_alpha_mag = Math.max(0, Math.min(1, Math.sqrt(alpha_mag_sq)));
            const theta = 2 * Math.acos(clamped_alpha_mag);
            let phi_beta = Math.atan2(state.beta.im, state.beta.re);
            let phi_alpha = Math.atan2(state.alpha.im, state.alpha.re);
            const phi = phi_beta - phi_alpha;
            return { theta, phi };
        }

        // --- Core Logic & Display ---
        // Target unitary chosen so identity has very low fidelity (target is far from I).
        function getFixedTargetUnitary() {
            const u = [[complex(0.567, -0.234), complex(-0.345, 0.678)], [complex(0.789, 0.123), complex(0.456, -0.567)]];
            let c0_0 = complex(u[0][0].re, u[0][0].im), c0_1 = complex(u[1][0].re, u[1][0].im);
            let c1_0 = complex(u[0][1].re, u[0][1].im), c1_1 = complex(u[1][1].re, u[1][1].im);
            let n0 = Math.sqrt(cabs_sq(c0_0) + cabs_sq(c0_1));
            if (n0 < 1e-12) n0 = 1;
            c0_0 = complex(c0_0.re / n0, c0_0.im / n0);
            c0_1 = complex(c0_1.re / n0, c0_1.im / n0);
            const dot = cadd(cmul(cconj(c0_0), c1_0), cmul(cconj(c0_1), c1_1));
            c1_0 = cadd(c1_0, complex(-dot.re * c0_0.re + dot.im * c0_0.im, -dot.re * c0_0.im - dot.im * c0_0.re));
            c1_1 = cadd(c1_1, complex(-dot.re * c0_1.re + dot.im * c0_1.im, -dot.re * c0_1.im - dot.im * c0_1.re));
            let n1 = Math.sqrt(cabs_sq(c1_0) + cabs_sq(c1_1));
            if (n1 < 1e-12) n1 = 1;
            c1_0 = complex(c1_0.re / n1, c1_0.im / n1);
            c1_1 = complex(c1_1.re / n1, c1_1.im / n1);
            let U = [[c0_0, c1_0], [c0_1, c1_1]];
            const det = cadd(cmul(U[0][0], U[1][1]), cmul(complex(-1), cmul(U[0][1], U[1][0])));
            const phase = Math.atan2(det.im, det.re);
            const phaseCorrection = complex(Math.cos(-phase), Math.sin(-phase));
            U[0][1] = cmul(phaseCorrection, U[0][1]);
            U[1][1] = cmul(phaseCorrection, U[1][1]);
            return U;
        }

        function updateBestScoreDisplay() {
            const fidelityEl = document.getElementById('best-fidelity-display');
            const sequenceEl = document.getElementById('best-sequence-display');
            if (bestFidelity < 0) {
                fidelityEl.textContent = 'N/A';
                sequenceEl.innerHTML = '<span class="text-gray-500">None</span>';
            } else {
                fidelityEl.textContent = bestFidelity.toFixed(5);
                sequenceEl.innerHTML = bestGateSequence.length > 0 ? bestGateSequence.join(' ') : '<span class="text-gray-500">Identity</span>';
            }
        }

        function calculateUnitaryDeviation() {
            const fidelity = unitaryFidelity(targetUnitary, userUnitary);

            const displayEl = document.getElementById('deviation-display');
            displayEl.textContent = fidelity.toFixed(5);
            displayEl.classList.toggle('text-green-300', fidelity > 0.9999);
            displayEl.classList.toggle('nvidia-green', fidelity <= 0.9999);

            if (fidelity > bestFidelity) {
                bestFidelity = fidelity;
                bestGateSequence = [...gateSequence];
                updateBestScoreDisplay();
            }
        }

        function formatComplexForMatrix(c) {
            const re = c.re.toFixed(2);
            const im = c.im.toFixed(2);
            if (Math.abs(c.im) < 1e-3) return `${re}`;
            if (Math.abs(c.re) < 1e-3) return `${im}j`;
            return `${re}${c.im >= 0 ? '+' : ''}${im}j`;
        }

        function displayMatrix(elementId, matrix) {
            const container = document.getElementById(elementId);
            if (!container.classList.contains('matrix-container')) {
                 container.classList.add('matrix-container');
            }
            const [ [c00, c01], [c10, c11] ] = matrix;
            container.innerHTML = `
                <span>${formatComplexForMatrix(c00)}</span><span>${formatComplexForMatrix(c01)}</span>
                <span>${formatComplexForMatrix(c10)}</span><span>${formatComplexForMatrix(c11)}</span>`;
        }
        
        function updateGateSequenceDisplay() {
            const displayEl = document.getElementById('gate-sequence-display');
            displayEl.innerHTML = gateSequence.length === 0 
                ? '<span class="text-gray-500">Empty</span>' 
                : gateSequence.join(' ');
        }
        
        function recalculateUserUnitary() {
            userUnitary = [[complex(1), complex(0)], [complex(0), complex(1)]];
            for (const gateName of gateSequence) {
                const gateMatrix = GATES[gateName];
                userUnitary = matrixMultiply(gateMatrix, userUnitary);
            }
        }
        
        function createBlochSphere(container) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3.5);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x000000, 1);
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.minDistance = 2.5;
            controls.maxDistance = 8;

            const group = new THREE.Group();
            scene.add(group);

            const sphereGeom = new THREE.SphereGeometry(1, 24, 24);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xAAAAAA, transparent: true, opacity: 0.15, wireframe: true });
            group.add(new THREE.Mesh(sphereGeom, sphereMat));

            const axisColor = 0xCCCCCC;
            const axisLen = 1.1;
            const axisMat = new THREE.LineBasicMaterial({ color: axisColor });
            [
                [new THREE.Vector3(0, 0, 0), new THREE.Vector3(axisLen, 0, 0)],
                [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, axisLen, 0)],
                [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, axisLen)],
            ].forEach(([a, b]) => {
                const geom = new THREE.BufferGeometry().setFromPoints([a, b]);
                group.add(new THREE.Line(geom, axisMat));
            });

            function createThickArrow(length, colorHex, opaque = true) {
                const shaftRadius = 0.035;
                const headRadius = 0.11;
                const headHeight = length * 0.22;
                const shaftLength = length - headHeight;
                const mat = new THREE.MeshBasicMaterial({
                    color: colorHex,
                    transparent: !opaque,
                    opacity: opaque ? 1 : 0.55
                });
                const shaft = new THREE.Mesh(new THREE.CylinderGeometry(shaftRadius, shaftRadius, shaftLength, 16), mat);
                shaft.rotation.x = Math.PI / 2;
                shaft.position.set(0, 0, shaftLength / 2);
                const head = new THREE.Mesh(new THREE.ConeGeometry(headRadius, headHeight, 16), mat);
                head.rotation.x = Math.PI / 2;
                head.position.set(0, 0, shaftLength + headHeight / 2);
                const g = new THREE.Group();
                g.add(shaft);
                g.add(head);
                return g;
            }
            const COLOR_0 = 0x76B900, COLOR_PLUS = 0x00b4d8, COLOR_I = 0xf4a261;
            const targetVector0 = createThickArrow(1, COLOR_0, true);
            const targetVectorPlus = createThickArrow(1, COLOR_PLUS, true);
            const targetVectorI = createThickArrow(1, COLOR_I, true);
            const userVector0 = createThickArrow(1, COLOR_0, false);
            const userVectorPlus = createThickArrow(1, COLOR_PLUS, false);
            const userVectorI = createThickArrow(1, COLOR_I, false);
            group.add(targetVector0); group.add(targetVectorPlus); group.add(targetVectorI);
            group.add(userVector0); group.add(userVectorPlus); group.add(userVectorI);

            const scale = Math.max(2, window.devicePixelRatio || 1);
            const createLabel = (text, position, fontSize = 32) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const logicalW = context.measureText(text).width + 20;
                const logicalH = fontSize * 1.5;
                canvas.width = logicalW * scale;
                canvas.height = logicalH * scale;
                context.scale(scale, scale);
                context.font = `Bold ${fontSize}px Inter`;
                context.fillStyle = "rgba(224, 224, 224, 0.95)";
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, logicalW / 2, logicalH / 2);
                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.scale.set(logicalW / 150, logicalH / 150, 1.0);
                sprite.position.copy(position);
                return sprite;
            };

            group.add(createLabel('|0⟩', new THREE.Vector3(0, 1.15, 0), 32));
            group.add(createLabel('|1⟩', new THREE.Vector3(0, -1.15, 0), 32));
            const axisFontSize = 28;
            group.add(createLabel('|+⟩', new THREE.Vector3(1.15, 0, 0), axisFontSize));
            group.add(createLabel('|-⟩', new THREE.Vector3(-1.15, 0, 0), axisFontSize));
            group.add(createLabel('|+i⟩', new THREE.Vector3(0, 0, 1.15), axisFontSize));
            group.add(createLabel('|-i⟩', new THREE.Vector3(0, 0, -1.15), axisFontSize));

            const onWindowResize = () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            };
            window.addEventListener('resize', onWindowResize);

            return {
                scene, camera, renderer, controls, onWindowResize,
                targetVectors: [targetVector0, targetVectorPlus, targetVectorI],
                userVectors: [userVector0, userVectorPlus, userVectorI]
            };
        }

        function updateVectorPosition(vector, state) {
            const { theta, phi } = stateToBloch(state);
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.cos(theta);
            const z = Math.sin(theta) * Math.sin(phi);
            const dir = new THREE.Vector3(x, y, z).normalize();
            const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), dir);
            vector.quaternion.copy(q);
        }

        const sphereContainer = document.getElementById('sphere-main');
        const viz = { sphere: createBlochSphere(sphereContainer) };

        function rotateBlochCamera(v, deltaAzimuth, deltaPolar) {
            const cam = v.camera;
            const pos = cam.position;
            let radius = pos.length();
            if (radius < 0.01) radius = 3.5;
            let theta = Math.acos(Math.max(-1, Math.min(1, pos.y / radius)));
            let phi = Math.atan2(pos.x, pos.z);
            theta = Math.max(0.01, Math.min(Math.PI - 0.01, theta + deltaPolar));
            phi += deltaAzimuth;
            cam.position.x = radius * Math.sin(theta) * Math.cos(phi);
            cam.position.y = radius * Math.cos(theta);
            cam.position.z = radius * Math.sin(theta) * Math.sin(phi);
        }

        document.addEventListener('keydown', (e) => {
            const el = document.activeElement;
            if (!el || el.id !== 'sphere-main' || !el.classList.contains('bloch-viewport')) return;
            if (e.ctrlKey || e.metaKey || e.altKey) return;
            const v = viz.sphere;
            const step = 0.08;
            if (e.key === 'ArrowLeft') { e.preventDefault(); rotateBlochCamera(v, step, 0); }
            else if (e.key === 'ArrowRight') { e.preventDefault(); rotateBlochCamera(v, -step, 0); }
            else if (e.key === 'ArrowUp') { e.preventDefault(); rotateBlochCamera(v, 0, -step); }
            else if (e.key === 'ArrowDown') { e.preventDefault(); rotateBlochCamera(v, 0, step); }
        });

        const basisStates = [state0, statePlus, stateI];
        function updateAllVisuals() {
            for (let i = 0; i < 3; i++) {
                const targetState = applyUnitaryToState(targetUnitary, basisStates[i]);
                const userState = applyUnitaryToState(userUnitary, basisStates[i]);
                updateVectorPosition(viz.sphere.targetVectors[i], targetState);
                updateVectorPosition(viz.sphere.userVectors[i], userState);
            }
            displayMatrix('target-matrix-display', targetUnitary);
            displayMatrix('user-matrix-display', userUnitary);
            calculateUnitaryDeviation();
            updateGateSequenceDisplay();
        }
        
        function resetCircuit() {
            gateSequence = [];
            recalculateUserUnitary();
            bestFidelity = -1;
            bestGateSequence = [];
            updateBestScoreDisplay();
            updateAllVisuals();
        }

        function runFidelityChecks() {
            const identity = [[complex(1), complex(0)], [complex(0), complex(1)]];
            console.log('[Unitary widget] === Fidelity checks ===');
            console.log('1. Target is unitary (U†U = I):', isUnitary(targetUnitary));
            const fidIdentity = unitaryFidelity(targetUnitary, identity);
            console.log('2. Fidelity(target, identity) =', fidIdentity.toFixed(6));
            const fidSelf = unitaryFidelity(targetUnitary, targetUnitary);
            console.log('3. Fidelity(target, target) =', fidSelf.toFixed(6), '(expect 1.0)');
            console.log('[Unitary widget] === End checks ===');
        }

        function initializeChallenge() {
            targetUnitary = getFixedTargetUnitary();
            resetCircuit();
            runFidelityChecks();
        }

        function animate() {
            requestAnimationFrame(animate);
            const v = viz.sphere;
            v.controls.update();
            v.renderer.render(v.scene, v.camera);
        }

        document.querySelectorAll('.gate-btn[data-gate]').forEach(button => {
            button.addEventListener('click', () => {
                gateSequence.push(button.dataset.gate);
                recalculateUserUnitary();
                updateAllVisuals();
            });
        });
        
        document.getElementById('reset-circuit-btn').addEventListener('click', resetCircuit);

        document.getElementById('undo-gate-btn').addEventListener('click', () => {
            if (gateSequence.length > 0) {
                gateSequence.pop();
                recalculateUserUnitary();
                updateAllVisuals();
            }
        });
        
        initializeChallenge();
        animate();
        
        setTimeout(() => viz.sphere.onWindowResize(), 100);

    </script>
</body>
</html>














