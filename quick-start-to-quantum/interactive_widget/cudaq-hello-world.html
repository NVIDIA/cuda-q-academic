<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CUDA-Q Kernel Visualizer & Designer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        :root { 
            --nvidia-green: #76b900; 
            --nvidia-green-hover: #6a9e00;
            --nvidia-dark: #333; 
            --bg-color: #f8f9fa; 
            --border-color: #ddd; 
            --code-bg: #2d2d2d; 
            --code-text: #f8f8f2; 
        }
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: var(--nvidia-dark); margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        .widget-container { background: white; border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); width: 100%; max-width: 1200px; display: flex; flex-direction: column; }
        
        /* --- CONTROLS --- */
        .controls { padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; background: #fff; border-radius: 8px 8px 0 0; }
        .control-group { display: flex; align-items: center; gap: 15px; }
        
        select, button, input { padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px; }
        button { cursor: pointer; }
        .btn-action { background-color: var(--nvidia-dark); color: white; border: 1px solid var(--nvidia-dark); font-weight: bold; font-size: 14px; transition: background-color 0.2s; }
        .btn-action:hover { background-color: #555; }
        
        #btn-execute {
            background-color: var(--nvidia-green);
            border: 1px solid var(--nvidia-green);
            color: white;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 12px;
            margin-top: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            transition: all 0.2s ease;
            width: 100%; /* Better for mobile */
        }
        #btn-execute:hover { background-color: var(--nvidia-green-hover); transform: translateY(-1px); }

        .btn-clear { background-color: #fff; border: 1px solid #e74c3c; color: #e74c3c; font-size: 12px; padding: 6px 12px; }
        .btn-clear:hover { background-color: #e74c3c; color: white; }
        .btn-undo { background-color: #fff; border: 1px solid #666; color: #666; font-size: 12px; padding: 6px 12px; display: flex; align-items: center; gap: 5px; }
        .btn-undo:hover { background-color: #666; color: white; }
        
        .btn-edit { background-color: #fff; border: 1px solid var(--nvidia-green); color: var(--nvidia-green); font-size: 12px; padding: 6px 12px; }
        .btn-edit:hover { background-color: var(--nvidia-green); color: white; }
        .btn-copy-gate { background-color: #fff; border: 1px solid #3498db; color: #3498db; font-size: 12px; padding: 6px 12px; }
        .btn-copy-gate:hover { background-color: #3498db; color: white; }
        .btn-copy { background-color: #eee; color: #333; border: 1px solid #ddd; font-size: 12px; display: flex; align-items: center; gap: 5px; }
        .btn-copy:hover { background-color: #e0e0e0; }
        
        /* WORKSPACE */
        .workspace { display: grid; grid-template-columns: 60% 40%; min-height: 650px; }
        
        .circuit-area { padding: 20px; border-right: 1px solid var(--border-color); display: flex; flex-direction: column; position: relative; }
        
        .gate-toolbar { display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap; padding-bottom: 15px; border-bottom: 1px dashed #eee; align-items: center; user-select: none; -webkit-user-select: none; }
        .gate-btn { 
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; 
            background: white; border: 2px solid var(--nvidia-green); color: var(--nvidia-green); 
            font-weight: bold; border-radius: 4px; cursor: grab; font-size: 11px; position: relative;
            touch-action: none; /* Crucial for mobile drag */
        }
        .gate-btn:hover { background: var(--nvidia-green); color: white; }
        .gate-btn.param-gate { background: #f0f9eb; border-color: var(--nvidia-green); color: var(--nvidia-green); }
        .gate-btn.custom { border-style: dashed; }
        .gate-btn.paste-btn { border: 2px dashed #3498db; color: #3498db; background: #f0f8ff; width: auto; padding: 0 10px; display: none; }
        .gate-btn.paste-btn.visible { display: flex; }
        
        .svg-container { 
            flex-grow: 1; 
            border: 1px dashed #eee; 
            border-radius: 4px; 
            min-height: 300px; 
            position: relative; 
            
            /* --- NEW LINES START --- */
            width: 100%;        /* Forces it to fill the parent, not the content */
            max-width: 85vw;    /* Hard limit prevents it from pushing page width */
            overflow: auto;     /* Enables scrollbars (both X and Y) */
            display: block;     /* Ensures standard box model behavior */
            /* --- NEW LINES END --- */

            background: #fff; 
            -webkit-overflow-scrolling: touch;
        }
        #circuit-svg { height: 100%; display: block; }
        
        /* SIDEBAR */
        .sidebar { background-color: #fafafa; display: flex; flex-direction: column; overflow-y: auto; max-height: 800px; }
        .code-block-wrapper { margin-bottom: 0; }
        .code-header { padding: 8px 10px; font-size: 11px; font-weight: bold; text-transform: uppercase; color: #777; background: #eee; border-top: 1px solid #ddd; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; }
        .code-box { background-color: var(--code-bg); color: var(--code-text); padding: 10px; font-family: 'Courier New', monospace; font-size: 12px; overflow: auto; white-space: pre-wrap; word-break: break-all; min-height: 100px; max-height: 250px; }
        .exec-panel { padding: 15px; border-top: 1px solid #ddd; background: white; flex-grow: 1; display: flex; flex-direction: column; }
        
        .mode-selector { display: flex; gap: 0; border: 1px solid #ccc; border-radius: 4px; overflow: hidden; margin-bottom: 15px; }
        .mode-btn { flex: 1; padding: 10px 5px; border: none; background: #f8f8f8; cursor: pointer; font-size: 12px; border-right: 1px solid #ccc; transition: background 0.1s; }
        .mode-btn:last-child { border-right: none; }
        .mode-btn:hover { background: #eee; }
        .mode-btn.active { background: #444; color: white; font-weight: bold; border-color: #444; }
        
        .run-config { padding: 15px; background: #f0f9eb; border: 1px solid #ccebc4; border-radius: 4px; margin-bottom: 15px; display: none; }
        .run-config.visible { display: block; }
        
        .meas-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 13px; gap: 10px; }
        .meas-row span { font-weight: bold; min-width: 35px; color: #333; }
        .meas-row select { padding: 5px; flex-grow: 1; width: auto; border: 1px solid #ccc; border-radius: 4px; background: white; }
        
        .results-display { margin-top: 15px; flex-grow: 1; display: flex; flex-direction: column; }
        .result-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-bottom: 10px; }
        .result-table th, .result-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .result-table th { background: #f4f4f4; }
        .raw-output { background: #eee; padding: 10px; font-family: monospace; font-size: 11px; max-height: 150px; overflow-y: auto; border-radius: 4px; margin-top: 5px; white-space: pre-wrap; word-break: break-all; }
        
        /* SVG ELEMENTS */
        line.wire { stroke: #999; stroke-width: 2; pointer-events: none; }
        line.control-line { stroke: #333; stroke-width: 2; pointer-events: none; }
        circle.control-dot { fill: #333; pointer-events: none; }
        g.gate-group { cursor: pointer; pointer-events: all; user-select: none; -webkit-user-select: none; }
        rect.gate-box { fill: #fff; stroke: var(--nvidia-green); stroke-width: 2; }
        text.gate-text { font-family: sans-serif; font-size: 11px; fill: #333; pointer-events: none; user-select: none; -webkit-user-select: none; font-weight: bold; }
        rect.gate-box.param { fill: var(--nvidia-green); stroke: var(--nvidia-green); }
        text.gate-text.param { fill: #fff; }
        #drop-indicator { stroke: #ff0000; stroke-width: 2; stroke-dasharray: 4; display: none; pointer-events: none; }
        #ghost-gate { opacity: 0.6; pointer-events: none; display: none; }

        /* TOUCH HELPER */
        #touch-helper {
            position: fixed; z-index: 9999; pointer-events: none; 
            width: 40px; height: 40px; background: rgba(118, 185, 0, 0.9);
            border: 2px solid #333; border-radius: 4px; color: white;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-family: sans-serif;
            transform: translate(-50%, -50%); display: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        /* MODAL */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 2000; visibility: hidden; opacity: 0; transition: opacity 0.2s; }
        .modal-overlay.open { visibility: visible; opacity: 1; }
        .modal { background: white; padding: 20px; border-radius: 8px; width: 400px; max-width: 90vw; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-size: 12px; color: #666; margin-bottom: 5px; }
        .form-group select, .form-group input, .form-group textarea { width: 100%; box-sizing: border-box; }
        .hidden { display: none !important; }
        
        /* TOOLTIP */
        #matrix-tooltip {
            position: absolute; background: rgba(40,40,40, 0.95); color: #fff; padding: 10px; 
            border-radius: 6px; font-family: 'Times New Roman', serif; font-size: 13px;
            pointer-events: none; z-index: 3000; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: none; white-space: nowrap;
        }
        .matrix-table { border-collapse: collapse; display: inline-table; vertical-align: middle; margin: 0 5px; }
        .matrix-table td { padding: 3px 6px; text-align: center; }
        .bracket { font-size: 2.5em; font-weight: 300; display: inline-block; vertical-align: middle; line-height: 0; position: relative; top: 2px;}

        /* FOOTER INFO */
        .footer-info { padding: 20px; background: #fafafa; border-top: 1px solid var(--border-color); border-radius: 0 0 8px 8px; }
        .info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px; margin-top: 10px; }
        .info-item { background: white; border: 1px solid #eee; padding: 10px; border-radius: 4px; border-left: 3px solid var(--nvidia-green); }
        .info-item h4 { margin: 0 0 5px 0; color: #333; font-size: 12px; font-weight: bold; }
        .info-item p { margin: 0; font-size: 11px; color: #666; line-height: 1.4; }
        .resource-links { margin-top: 25px; padding-top: 15px; border-top: 1px dashed #ddd; display: flex; gap: 20px; justify-content: center; }
        .resource-link { display: flex; align-items: center; gap: 8px; text-decoration: none; color: #333; font-size: 13px; font-weight: bold; padding: 8px 15px; background: white; border: 1px solid #ddd; border-radius: 4px; transition: all 0.2s ease; }
        .resource-link:hover { border-color: var(--nvidia-green); color: var(--nvidia-green); transform: translateY(-1px); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }

        /* --- MOBILE RESPONSIVENESS --- */
        @media (max-width: 768px) {
            body { padding: 5px; }
            .widget-container { width: 100%; border: none; box-shadow: none; }
            .workspace { grid-template-columns: 1fr; display: flex; flex-direction: column; }
            .sidebar { border-left: none; border-top: 1px solid #ddd; max-height: none; }
            .controls { flex-direction: column; align-items: stretch; gap: 10px; }
            .control-group { flex-direction: column; align-items: stretch; width: 100%; gap: 10px; }
            .control-group label { display: flex; flex-direction: column; font-size: 12px; }
            select { width: 100%; }
            .circuit-area { padding: 10px; min-height: 400px; }
            .gate-toolbar { justify-content: flex-start; gap: 5px; }
            .gate-btn { width: 44px; height: 44px; font-size: 12px; } 
            .circuit-area > div:last-child { flex-direction: column; align-items: stretch; }
            .circuit-area button { margin-bottom: 5px; justify-content: center; }
            #matrix-tooltip { display: none !important; } /* Hide tooltip on touch */
            .modal { padding: 15px; width: 95%; }
            #action-popup { padding: 8px; transform: translate(-50%, -140%); }
            #action-popup button { font-size: 14px; padding: 8px 12px; }
        }
    </style>
</head>
<body>

<div id="touch-helper"></div>
<div id="matrix-tooltip"></div>

<div id="action-popup" style="position:absolute; background:#333; padding:5px; border-radius:4px; display:flex; gap:5px; z-index:1000; transform:translate(-50%, -120%);" class="hidden">
    <button class="btn-edit" onclick="editSelectedGate()" style="background:none; border-color:white; color:white; padding:4px 8px;">Edit</button>
    <div style="width:1px; background:#666; margin: 2px 0;"></div>
    <button id="btn-popup-copy" class="btn-copy-gate" onclick="copySelectedGate()" style="background:none; border-color:white; color:white; padding:4px 8px;">Copy</button>
    <div id="sep-popup-copy" style="width:1px; background:#666; margin: 2px 0;"></div>
    <button class="btn-clear" onclick="deleteSelectedGate()" style="color:#ff6b6b; border-color: transparent; background:none; font-weight:bold; padding:4px 8px;">Delete</button>
</div>

<div id="limit-modal" class="modal-overlay">
    <div class="modal" style="width: 500px; border-top: 4px solid #f39c12;">
        <h3 style="margin-top:0; color: #e67e22;">Circuit Limit Reached</h3>
        <p style="font-size:14px; line-height: 1.5; color: #555;">
            You have reached the limit of <strong>10 gates per qubit line</strong>.
        </p>
        <div style="background:#f9f9f9; padding:10px; border-radius:4px; font-size:13px; color:#333; border:1px solid #eee; margin:15px 0;">
            <strong>Recommendation:</strong><br>
            For larger circuits, please copy the code and use the full <code>cudaq</code> environment.
        </div>
        <div style="text-align:right;">
            <button class="btn-action" onclick="closeLimitModal()">Understood</button>
        </div>
    </div>
</div>

<div id="gate-modal" class="modal-overlay">
    <div class="modal">
        <h3 id="modal-title" style="margin-top:0;">Configure Gate</h3>
        <div id="modal-content"></div>
        <div id="modal-error" style="color:red; font-size:12px; margin-bottom:10px; display:none;"></div>
        <div style="text-align:right; margin-top:15px;">
            <button onclick="closeModal()">Cancel</button>
            <button class="btn-action" style="background-color: var(--nvidia-green); border:none;" onclick="confirmModalGate()">Save</button>
        </div>
    </div>
</div>

<div class="widget-container">
    <div class="controls">
        <div class="control-group">
            <strong>CUDA-Q Hello World</strong>
            <label style="font-size:14px;">
                Qubits: 
                <select id="qubit-select" onchange="updateQubits(this.value)" style="width:auto; min-width: 50px;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </label>
            
            <span style="color:#ccc; margin:0 5px;" class="hide-mobile">|</span>
            <label style="font-size:14px;">
                Load Example:
                <select id="example-select" onchange="loadExample(this.value)" style="width:200px;">
                    <option value="">-- Select Circuit --</option>
                    <option value="bell">Bell State (|Œ¶‚Å∫‚ü©)</option>
                    <option value="ghz">GHZ State (3-Qubit)</option>
                    <option value="bv">Bernstein-Vazirani</option>
                    <option value="teleport">Teleportation</option>
                </select>
            </label>
        </div>
    </div>

    <div class="workspace">
        <div class="circuit-area" id="circuit-area">
            <div class="gate-toolbar">
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 'h')" onmouseenter="showTooltip(event, 'h')" onmouseleave="hideTooltip()" data-type="h">H</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 'x')" onmouseenter="showTooltip(event, 'x')" onmouseleave="hideTooltip()" data-type="x">X</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 'y')" onmouseenter="showTooltip(event, 'y')" onmouseleave="hideTooltip()" data-type="y">Y</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 'z')" onmouseenter="showTooltip(event, 'z')" onmouseleave="hideTooltip()" data-type="z">Z</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 's')" onmouseenter="showTooltip(event, 's')" onmouseleave="hideTooltip()" data-type="s">S</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 't')" onmouseenter="showTooltip(event, 't')" onmouseleave="hideTooltip()" data-type="t">T</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 'cx')" onmouseenter="showTooltip(event, 'cx')" onmouseleave="hideTooltip()" style="border-color:#333; color:#333;" data-type="cx">CNOT</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 'cz')" onmouseenter="showTooltip(event, 'cz')" onmouseleave="hideTooltip()" style="border-color:#333; color:#333;" data-type="cz">CZ</div>
                <div class="gate-btn" draggable="true" ondragstart="dragStartNew(event, 'swap')" onmouseenter="showTooltip(event, 'swap')" onmouseleave="hideTooltip()" style="border-color:#333; color:#333;" data-type="swap">SWAP</div>
                <div class="gate-btn param-gate" draggable="true" ondragstart="dragStartNew(event, 'rx')" onmouseenter="showTooltip(event, 'rx')" onmouseleave="hideTooltip()" data-type="rx">RX</div>
                <div class="gate-btn param-gate" draggable="true" ondragstart="dragStartNew(event, 'ry')" onmouseenter="showTooltip(event, 'ry')" onmouseleave="hideTooltip()" data-type="ry">RY</div>
                <div class="gate-btn param-gate" draggable="true" ondragstart="dragStartNew(event, 'rz')" onmouseenter="showTooltip(event, 'rz')" onmouseleave="hideTooltip()" data-type="rz">RZ</div>
                <div class="gate-btn param-gate" draggable="true" ondragstart="dragStartNew(event, 'u3')" onmouseenter="showTooltip(event, 'u3')" onmouseleave="hideTooltip()" data-type="u3">U3</div>
                <div class="gate-btn custom" draggable="true" ondragstart="dragStartNew(event, 'custom')" data-type="custom">Custom</div>
                <div id="btn-paste" class="gate-btn paste-btn" draggable="true" ondragstart="dragStartPaste(event)" data-type="paste">üìã Paste</div>
            </div>
            
            <div class="svg-container">
                <svg id="circuit-svg" ondragover="dragOver(event)" ondragleave="dragLeave(event)" ondrop="dropOnSvg(event)" onclick="bgClick(event)">
                    <line id="drop-indicator" x1="0" y1="0" x2="0" y2="400"></line>
                    <g id="ghost-gate">
                        <rect width="30" height="30" x="-15" y="-15" fill="rgba(118, 185, 0, 0.5)" stroke="#333" stroke-dasharray="2"></rect>
                        <text id="ghost-text" x="0" y="5" text-anchor="middle" font-family="sans-serif" font-size="12px" fill="#fff">G</text>
                    </g>
                </svg>
            </div>
            <div style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 10px; flex-wrap: wrap;">
                <button id="btn-copy-kernel" class="btn-copy" onclick="copyKernelOnly()" style="background: white; border: 1px solid #ccc; padding: 6px 12px;">üìã Copy CUDA-Q Code</button>
                <button id="btn-copy-full" class="btn-copy" onclick="copyFullViz()" style="background: white; border: 1px solid #ccc; padding: 6px 12px;">üìä Copy CUDA-Q + Viz Code</button>
                <button id="btn-share" class="btn-copy" onclick="generateShareLink()" style="background: white; border: 1px solid #ccc; padding: 6px 12px;">üîó Share Circuit</button>
                <div style="border-left: 1px solid #ddd; margin: 0 5px;" class="hide-mobile"></div>
                <button class="btn-undo" onclick="undo()" title="Undo Last Action">‚éå Undo</button>
                <button class="btn-clear" onclick="clearAll()">Clear Circuit</button>
            </div>
        </div> 

        <div class="sidebar">
            <div class="code-block-wrapper">
                <div class="code-header"><span>Generated Kernel</span></div>
                <div class="code-box" id="code-kernel"></div>
            </div>

            <div class="exec-panel">
                <label style="font-size:12px; font-weight:bold; margin-bottom:5px;">Execution Mode</label>
                <div class="mode-selector">
                    <button class="mode-btn" id="mode-state" onclick="setMode('state')">Get State</button>
                    <button class="mode-btn active" id="mode-sample" onclick="setMode('sample')">Sample</button>
                    <button class="mode-btn" id="mode-run" onclick="setMode('run')">Run</button>
                </div>
                
                <div id="run-config" class="run-config">
                    <div style="font-size:11px; font-weight:bold; margin-bottom:8px;">Measurements:</div>
                    <div id="meas-list"></div>
                </div>
                
                <div class="code-block-wrapper" style="margin-top:10px;">
                    <div class="code-header"><span>Execution Code</span></div>
                    <div class="code-box" id="code-exec" style="min-height:60px; max-height:80px;"></div>
                </div>

                <button id="btn-execute" class="btn-action" onclick="executeCircuit()">‚ñ∂ Execute</button>
                
                <div class="results-display" id="results-area">
                    <div id="chart-wrapper" style="display:none; width:100%;">
                        <canvas id="chart-canvas" style="max-height:200px; width:100%;"></canvas>
                    </div>
                    <div id="table-container"></div>
                    <div id="raw-container" style="display:none;">
                        <div style="font-size:11px; font-weight:bold; margin-top:10px;">Raw Output:</div>
                        <div class="raw-output" id="raw-text"></div>
                    </div>
                </div>
            </div>
        </div>

    </div>
    
    <div class="footer-info">
        <div style="margin-bottom: 25px; padding-bottom: 25px; border-bottom: 1px dashed #ddd;">
            <h3 style="margin:0 0 15px 0; font-size:13px; color:#444; text-transform:uppercase; letter-spacing:0.5px;">Instructions</h3>
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:20px; font-size:12px; color:#555;">
                <div>
                    <strong style="color:#333;">1. Build Circuit</strong>
                    <p style="margin:5px 0 0 0;">Drag gates (Mouse or Touch). Click a placed gate to <strong>Edit, Copy, or Delete</strong>.</p>
                </div>
                 <div>
                    <strong style="color:#333;">2. Select Execution Mode</strong>
                    <p style="margin:5px 0 0 0;">
                        <strong>Get State:</strong> View probability amplitudes.<br>
                        <strong>Sample:</strong> Simulate 1000 noise-free shots.<br>
                        <strong>Run:</strong> Shot-based execution with specific measurements.
                    </p>
                </div>
                <div>
                    <strong style="color:#333;">3. Generate Code</strong>
                    <p style="margin:5px 0 0 0;">The sidebar automatically generates <code>cudaq</code> Python code. Click the "Copy" buttons to use locally.</p>
                </div>
            </div>
        </div>

        <h3 style="margin:0 0 10px 0; font-size:13px; color:#444; text-transform:uppercase; letter-spacing:0.5px;">Example Circuits Guide</h3>
        <div class="info-grid">
            <div class="info-item">
                <h4>Bell State (|Œ¶‚Å∫‚ü©)</h4>
                <p><strong>2 Qubits:</strong> The simplest example of entanglement. Measures <code>00</code> or <code>11</code> with 50/50 probability.</p>
            </div>
            <div class="info-item">
                <h4>GHZ State</h4>
                <p><strong>3 Qubits:</strong> Maximally entangled state for 3 qubits. Results are <code>000</code> or <code>111</code>.</p>
            </div>
            <div class="info-item">
                <h4>Bernstein-Vazirani</h4>
                <p><strong>3 Qubits:</strong> Finds a secret bitstring (101) hidden in an Oracle function in a single step.</p>
            </div>
            <div class="info-item">
                <h4>Quantum Teleportation</h4>
                <p><strong>3 Qubits:</strong> Teleports state from q0 to q2. <br> 
                We prepare q0 in the state, |-i>. When teleported, we verify it by measuring q2 in the <code>my</code> basis. 
                In "Run" mode, q2 should be <code>True</code> 100% of the time.</p>
            </div>
        </div>

        <div class="resource-links">
            <a href="https://github.com/NVIDIA/cuda-q-academic" target="_blank" class="resource-link">
                <span class="resource-icon">üéì</span> CUDA-Q Academic Repository
            </a>
            <a href="https://nvidia.github.io/cuda-quantum/" target="_blank" class="resource-link">
                <span class="resource-icon">üìö</span> CUDA-Q Documentation
            </a>
        </div>
    </div>
</div> 

<script>
    let numQubits = 3;
    let circuit = []; 
    let execMode = 'sample'; 
    let measurements = {}; 
    let customOps = {}; 
    let pendingInsertIdx = -1;
    let clipboardOp = null;
    let selectedIdx = -1;
    
    // History Stack for Undo
    let historyStack = [];

    const MAX_GATES_PER_QUBIT = 10;
    const svg = document.getElementById('circuit-svg');
    const indicator = document.getElementById('drop-indicator');
    const popup = document.getElementById('action-popup');
    const ghost = document.getElementById('ghost-gate');
    const measList = document.getElementById('meas-list');
    const tooltip = document.getElementById('matrix-tooltip');
    
    // TOUCH: Touch Helper
    const touchHelper = document.getElementById('touch-helper');
    let touchGate = null;

    const EXAMPLES = {
        'bell': { n: 2, c: [{ gate: 'h', target: 0, control: null, target2: null, params: [] }, { gate: 'cx', target: 1, control: 0, target2: null, params: [] }] },
        'ghz': { n: 3, c: [{ gate: 'h', target: 0, control: null, target2: null, params: [] }, { gate: 'cx', target: 1, control: 0, target2: null, params: [] }, { gate: 'cx', target: 2, control: 1, target2: null, params: [] }] },
        'bv': { n: 3, c: [{ gate: 'h', target: 0, control: null, target2: null, params: [] }, { gate: 'h', target: 1, control: null, target2: null, params: [] }, { gate: 'h', target: 2, control: null, target2: null, params: [] }, { gate: 'z', target: 0, control: null, target2: null, params: [] }, { gate: 'z', target: 2, control: null, target2: null, params: [] }, { gate: 'h', target: 0, control: null, target2: null, params: [] }, { gate: 'h', target: 1, control: null, target2: null, params: [] }, { gate: 'h', target: 2, control: null, target2: null, params: [] }] },
        'teleport': { n: 3, c: [{ gate: 'h', target: 1, control: null, target2: null, params: [] }, { gate: 'cx', target: 2, control: 1, target2: null, params: [] }, { gate: 'rx', target: 0, control: null, target2: null, params: [1.57] }, { gate: 'cx', target: 1, control: 0, target2: null, params: [] }, { gate: 'h', target: 0, control: null, target2: null, params: [] }, { gate: 'cx', target: 2, control: 1, target2: null, params: [] }, { gate: 'cz', target: 2, control: 0, target2: null, params: [] }] }
    };

    function saveState() {
        historyStack.push({
            c: JSON.parse(JSON.stringify(circuit)),
            o: JSON.parse(JSON.stringify(customOps))
        });
        if(historyStack.length > 30) historyStack.shift();
    }

    function undo() {
        if(historyStack.length === 0) return;
        const lastState = historyStack.pop();
        circuit = lastState.c;
        customOps = lastState.o;
        finishUpdate(true);
    }

    function loadExample(key) {
        if (!key || !EXAMPLES[key]) return;
        saveState();
        const ex = EXAMPLES[key];
        document.getElementById('qubit-select').value = ex.n;
        updateQubits(ex.n, true);
        circuit = JSON.parse(JSON.stringify(ex.c));
        measurements = {}; 
        for(let i=0; i<numQubits; i++) measurements[i] = 'mz';
        if (key === 'teleport') {
            setMode('run'); 
            measurements[2] = 'my'; measurements[0] = 'none'; measurements[1] = 'none';
        } else setMode('sample');
        finishUpdate(true);
        document.getElementById('example-select').value = "";
    }
    const GATE_META = {
        'h': { type: 'simple', label: 'H' }, 'x': { type: 'simple', label: 'X' }, 'y': { type: 'simple', label: 'Y' }, 'z': { type: 'simple', label: 'Z' },
        's': { type: 'simple', label: 'S' }, 't': { type: 'simple', label: 'T' }, 'cx': { type: 'control', label: 'CNOT' }, 'cz': { type: 'control', label: 'CZ' },
        'swap': { type: 'swap', label: 'SWAP' }, 'rx': { type: 'param', label: 'RX', params: ['theta'] }, 'ry': { type: 'param', label: 'RY', params: ['theta'] },
        'rz': { type: 'param', label: 'RZ', params: ['lambda'] }, 'u3': { type: 'param', label: 'U3', params: ['theta', 'phi', 'lambda'] }, 'custom': { type: 'custom', label: '?' }
    };
    const GATE_MATRICES = {
        'h': '1/‚àö2 [[1, 1], [1, -1]]', 'x': '[[0, 1], [1, 0]]', 'y': '[[0, -i], [i, 0]]', 'z': '[[1, 0], [0, -1]]',
        's': '[[1, 0], [0, i]]', 't': '[[1, 0], [0, e^(iœÄ/4)]]', 'rx': '[[cos(Œ∏/2), -i¬∑sin(Œ∏/2)], [-i¬∑sin(Œ∏/2), cos(Œ∏/2)]]',
        'ry': '[[cos(Œ∏/2), -sin(Œ∏/2)], [sin(Œ∏/2), cos(Œ∏/2)]]', 'rz': '[[e^(-iŒª/2), 0], [0, e^(iŒª/2)]]',
        'u3': '[[cos(Œ∏/2), -e^(iŒª)sin(Œ∏/2)], [e^(iœï)sin(Œ∏/2), e^(i(œï+Œª))cos(Œ∏/2)]]', 'cx': '4x4 CNOT (Control-X)', 'cz': '4x4 CZ (Control-Z)', 'swap': '4x4 SWAP'
    };

    window.onload = () => {
        // Init Touch Listeners Programmatically
        document.querySelectorAll('.gate-btn').forEach(btn => {
            btn.addEventListener('touchstart', handleTouchStart, {passive: false});
            btn.addEventListener('touchmove', handleTouchMove, {passive: false});
            btn.addEventListener('touchend', handleTouchEnd);
        });

        const urlParams = new URLSearchParams(window.location.search);
        const encodedState = urlParams.get('state');
        let loadedMode = 'sample';
        
        if (encodedState) {
            try {
                const data = JSON.parse(atob(encodedState));
                numQubits = data.n; 
                circuit = data.c;
                if (data.ops) { for(let key in data.ops) { try { customOps[key] = { matrix: parseMatrix(data.ops[key].definition), definition: data.ops[key].definition }; } catch(e) {} } }
                if(data.mode) loadedMode = data.mode;
                if(data.m) { measurements = data.m; } 
                else { for(let i=0; i<numQubits; i++) measurements[i] = 'mz'; }
                document.getElementById('qubit-select').value = numQubits;
            } catch (e) { 
                updateQubits(3); 
                for(let i=0; i<numQubits; i++) measurements[i] = 'mz';
            }
        } else {
             for(let i=0; i<numQubits; i++) measurements[i] = 'mz';
        }
        
        setMode(loadedMode);
        finishUpdate(true);
    };

    // --- TOUCH LOGIC START ---
    function handleTouchStart(e) {
        e.preventDefault();
        const target = e.currentTarget;
        const type = target.dataset.type;
        touchGate = type;
        touchHelper.textContent = target.textContent;
        touchHelper.style.display = 'flex';
        moveTouchHelper(e.touches[0].clientX, e.touches[0].clientY);
        hideTooltip();
    }

    function handleTouchMove(e) {
        if(!touchGate) return;
        e.preventDefault();
        const touch = e.touches[0];
        moveTouchHelper(touch.clientX, touch.clientY);
        
        // Show indicator if over svg
        const rect = svg.getBoundingClientRect();
        if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
             const { qubit, index } = calculateDropTarget(touch.clientX, touch.clientY);
             indicator.style.display = "block";
             // Reuse indicator logic from dragOver would be better, but basic pos is enough
             // Just show vertical line at correct spot?
             // Simplification: We reuse the drag logic variables conceptually
        } else {
             indicator.style.display = "none";
        }
    }

    function handleTouchEnd(e) {
        if(!touchGate) return;
        touchHelper.style.display = 'none';
        indicator.style.display = 'none';
        
        const touch = e.changedTouches[0];
        const rect = svg.getBoundingClientRect();
        
        if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
            touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
            
            const { qubit, index } = calculateDropTarget(touch.clientX, touch.clientY);
            
            // Map touchGate type to drag logic
            if(touchGate === 'paste') {
                if(clipboardOp) {
                    saveState();
                    const newOp = JSON.parse(JSON.stringify(clipboardOp));
                    newOp.target = qubit;
                    if(newOp.control !== null && newOp.control === qubit) newOp.control = (qubit === 0) ? 1 : 0;
                    if(newOp.gate === 'custom' && !customOps[newOp.customName] && newOp._definition) {
                        customOps[newOp.customName] = newOp._definition;
                    }
                    if (!isWithinLimit(newOp)) { showLimitModal(); }
                    else { circuit.splice(index, 0, newOp); finishUpdate(true); }
                }
            } else if (GATE_META[touchGate]) {
                const meta = GATE_META[touchGate];
                if (meta.type === 'simple') {
                    saveState();
                    if (!isWithinLimit({ gate: touchGate, target: qubit, control: null, target2: null })) { showLimitModal(); }
                    else {
                        circuit.splice(index, 0, { gate: touchGate, target: qubit, control: null, target2: null, params: [], customName: null });
                        finishUpdate(true);
                    }
                } else openModal(touchGate, -1, qubit, index); // Pass index to modal
            }
        }
        touchGate = null;
    }

    function moveTouchHelper(x, y) {
        touchHelper.style.left = x + 'px';
        touchHelper.style.top = (y - 50) + 'px';
    }

    function calculateDropTarget(clientX, clientY) {
        const rect = svg.getBoundingClientRect();
        const scrollX = svg.parentElement.scrollLeft;
        const lineH = 400 / (numQubits + 1);
        
        // Find Qubit
        let targetQubit = 0, minD = 999;
        for(let i=0; i<numQubits; i++) { 
            const d = Math.abs((clientY - rect.top) - (lineH * (i+1))); 
            if(d < minD) { minD = d; targetQubit = i; } 
        }
        
        // Find Index
        let maxBoxWidth = 30; 
        circuit.forEach(op => { if(op.gate === 'custom') maxBoxWidth = Math.max(maxBoxWidth, 60); if(['rx','ry','rz','u3'].includes(op.gate)) maxBoxWidth = Math.max(maxBoxWidth, 70); });
        const spacing = (maxBoxWidth > 40) ? 80 : 60; 
        let idx = Math.round(((clientX - rect.left + scrollX) - 80) / spacing);
        if (idx < 0) idx = 0; 
        if (idx > circuit.length) idx = circuit.length;
        
        return { qubit: targetQubit, index: idx };
    }
    // --- TOUCH LOGIC END ---

    function updateQubits(n, skipSave = false) {
        if(!skipSave) saveState();
        numQubits = parseInt(n);
        circuit = circuit.filter(op => {
            if (op.target >= numQubits) return false;
            if (op.control !== null && op.control >= numQubits) return false;
            if (op.gate === 'swap' && op.target2 >= numQubits) return false;
            return true;
        });
        measurements = {}; 
        for(let i=0; i<numQubits; i++) measurements[i] = 'mz';
        finishUpdate(true);
    }

    function renderMeasConfig() {
        measList.innerHTML = '';
        for(let i=0; i<numQubits; i++) {
            const row = document.createElement('div'); row.className = 'meas-row';
            row.innerHTML = `<span>q[${i}]</span><select onchange="measurements[${i}] = this.value; updateCode();">
                <option value="mz" ${measurements[i]==='mz'?'selected':''}>mz</option>
                <option value="mx" ${measurements[i]==='mx'?'selected':''}>mx</option>
                <option value="my" ${measurements[i]==='my'?'selected':''}>my</option>
                <option value="none" ${measurements[i]==='none'?'selected':''}>None</option>
            </select>`;
            measList.appendChild(row);
        }
    }

    function setMode(mode) {
        execMode = mode;
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`mode-${mode}`).classList.add('active');
        document.getElementById('run-config').classList.toggle('visible', mode === 'run');
        updateCode();
        document.getElementById('table-container').innerHTML = ''; 
        document.getElementById('chart-wrapper').style.display = 'none';
        document.getElementById('raw-container').style.display = 'none';
    }

    function showTooltip(e, type) {
        const raw = GATE_MATRICES[type]; if(!raw) return;
        let html = '';
        if (raw.includes('[[')) {
            let prefix = raw.split('[[')[0].trim();
            let content = raw.substring(raw.indexOf('[['));
            content = content.replace(/\[\[/g,'').replace(/\]\]/g,'').replace(/\], \[\s*/g, '|');
            let rows = content.split('|'); let r1 = rows[0].split(', '); let r2 = rows[1].split(', ');
            html = `<div style="text-align:center; font-weight:bold; margin-bottom:5px; color:#aaa;">${type.toUpperCase()} Gate</div>`;
            html += `<div style="display:flex; align-items:center; justify-content:center;">`;
            if(prefix) html += `<span style="margin-right:5px;">${prefix}</span>`;
            html += `<span class="bracket">[</span><table class="matrix-table">`;
            html += `<tr><td>${r1[0]}</td><td>${r1[1]}</td></tr>`;
            html += `<tr><td>${r2[0]}</td><td>${r2[1]}</td></tr>`;
            html += `</table><span class="bracket">]</span></div>`;
        } else html = `<strong>${type.toUpperCase()}</strong><br>${raw}`;
        tooltip.innerHTML = html; tooltip.style.display = 'block';
        const rect = e.target.getBoundingClientRect();
        tooltip.style.left = (rect.left + window.scrollX - 20) + 'px';
        tooltip.style.top = (rect.bottom + window.scrollY + 5) + 'px';
    }
    
    function hideTooltip() { tooltip.style.display = 'none'; }

    // Helper to format matrix string for Python syntax
    function formatPythonMatrix(rawStr) {
        let s = rawStr;
        // Replace common math functions with numpy equivalent
        s = s.replace(/\bsqrt\b/g, 'np.sqrt');
        s = s.replace(/\bpi\b/g, 'np.pi');
        s = s.replace(/\bsin\b/g, 'np.sin');
        s = s.replace(/\bcos\b/g, 'np.cos');
        s = s.replace(/\bexp\b/g, 'np.exp');
        
        // Replace standalone 'i' or 'j' with '1j' (complex unit in Python)
        // Checks for i/j not preceded or followed by alphanumeric chars
        s = s.replace(/(?<![a-zA-Z0-9_])i(?![a-zA-Z0-9_])/g, '1j');
        s = s.replace(/(?<![a-zA-Z0-9_])j(?![a-zA-Z0-9_])/g, '1j');
        
        return s;
    }

    function updateCode() {
        // Always include imports at the top
        let k = 'import cudaq\nimport numpy as np\n\n';
        
        const usedCustomOps = new Set();
        circuit.forEach(op => { if (op.gate === 'custom' && op.customName) usedCustomOps.add(op.customName); });
        
        usedCustomOps.forEach(name => { 
            if (customOps[name]) {
                // Use the python formatter here for the generated code
                let pyDef = formatPythonMatrix(customOps[name].definition);
                k += `cudaq.register_operation("${name}", ${pyDef})\n\n`; 
            }
        });
        
        let am = 0; if (execMode === 'run') for(let i=0; i<numQubits; i++) if(measurements[i] !== 'none') am++;
        if (execMode === 'run') k += `@cudaq.kernel\ndef my_kernel(n: int)${am===1?' -> bool':' -> list[bool]'}:\n    q = cudaq.qvector(n)\n`;
        else k += `@cudaq.kernel\ndef my_kernel(n: int):\n    q = cudaq.qvector(n)\n`;
        circuit.forEach(op => {
            let line = '';
            if (op.gate === 'custom') line = `    ${op.customName}(q[${op.target}])`;
            else if (GATE_META[op.gate].type === 'control') {
                if(op.gate === 'cx') line = `    x.ctrl(q[${op.control}], q[${op.target}])`;
                else if(op.gate === 'cz') line = `    z.ctrl(q[${op.control}], q[${op.target}])`;
            } else if (GATE_META[op.gate].type === 'swap') line = `    swap(q[${op.target}], q[${op.target2}])`;
            else if (GATE_META[op.gate].type === 'param') line = `    ${op.gate}(${op.params.join(', ')}, q[${op.target}])`;
            else line = `    ${op.gate}(q[${op.target}])`;
            k += line + '\n';
        });

        if (execMode === 'run') {
             let active = [];
             for(let i=0; i<numQubits; i++) if(measurements[i] !== 'none') active.push(i);
             if (active.length === 1) k += `    measurements = ${measurements[active[0]]}(q[${active[0]}])\n    return measurements`;
             else if (active.length > 1) k += `    measurements = [${active.map(i => `${measurements[i]}(q[${i}])`).join(', ')}]\n    return measurements`;
             else k += `    return [] # Warning: Select measurements`;
        }
        document.getElementById('code-kernel').innerText = k;
        let e = `n = ${numQubits}\n`;
        if (execMode === 'state') e += `state = cudaq.get_state(my_kernel, n)\nprint(state)`;
        else if (execMode === 'sample') e += `counts = cudaq.sample(my_kernel, n, shots_count=1000)\nprint(counts)`;
        else e += `results = cudaq.run(my_kernel, n, shots_count=20)\nprint(results)`;
        document.getElementById('code-exec').innerText = e;
    }

    function copyKernelOnly() {
        // Imports are now part of code-kernel text, so we don't prepend them manually here to avoid duplicates
        const txt = document.getElementById('code-kernel').innerText + "\n\n" + document.getElementById('code-exec').innerText;
        navigator.clipboard.writeText(txt).then(() => {
             const btn = document.getElementById('btn-copy-kernel');
             const orig = btn.innerHTML;
             btn.innerHTML = "<span>‚úì Copied!</span>"; btn.style.backgroundColor = "#ccebc4";
             setTimeout(() => { btn.innerHTML = orig; btn.style.backgroundColor = "white"; }, 2000);
        });
    }

    function copyFullViz() {
        let py = "";
        // Imports are already in code-kernel text
        py += document.getElementById('code-kernel').innerText + "\n\n";
        
        // Only include matplotlib if we are NOT in 'run' mode (since 'run' now uses a text table)
        if (execMode !== 'run') {
            py += "import matplotlib.pyplot as plt\n"; 
        }
        
        py += document.getElementById('code-exec').innerText + "\n\n";
        py += "# --- VISUALIZATION LOGIC ---\n";
        
        if (execMode === 'state') {
            py += `
data = np.array(state)
n = ${numQubits}
dim = 1 << n

# 1. Print the full array of coefficients
print('Statevector array of coefficients:', np.round(data, 4))

print("\\nState Vector Amplitudes:")
labels = []
values = []

for i in range(dim):
    if np.abs(data[i]) > 1e-6:
        bin_str = format(i, f'0{n}b')[::-1] 
        amp = np.round(data[i], 4)
        print(f"|{bin_str}>    {amp}")
        labels.append(f"|{bin_str}>")
        values.append(np.abs(data[i])**2) 

plt.bar(labels, values)
plt.ylabel('Probability')
plt.show()`;

        } else if (execMode === 'sample') {
            py += `
sorted_counts = dict(sorted(counts.items()))
print(sorted_counts)
plt.bar(list(sorted_counts.keys()), list(sorted_counts.values()))
plt.show()`;

        } else if (execMode === 'run') {
            // --- UPDATED: Prints Text Table instead of Bar Chart ---
            py += `
from collections import Counter

# Convert measurement results to strings for counting
# This handles both single bools (True) and lists ([True, False])
processed_results = [str(r) for r in results]
counts = Counter(processed_results)

# Print formatted table
print("\\nExecution Results:")
print(f"{'Result (1=True)':<25} | {'Count':<10}")
print("-" * 38)
for result, count in counts.items():
    print(f"{result:<25} | {count:<10}")
`;
            // ------------------------------------------------------
        }

        navigator.clipboard.writeText(py).then(() => {
             const btn = document.getElementById('btn-copy-full');
             const orig = btn.innerHTML;
             btn.innerHTML = "<span>‚úì Copied!</span>"; btn.style.backgroundColor = "#ccebc4";
             setTimeout(() => { btn.innerHTML = orig; btn.style.backgroundColor = "white"; }, 2000);
        });
    }

    function generateShareLink() {
        const opsToSave = {};
        for(let key in customOps) opsToSave[key] = { definition: customOps[key].definition };
        const data = { n: numQubits, c: circuit, ops: opsToSave, mode: execMode, m: measurements };
        const encoded = btoa(JSON.stringify(data));
        const newUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}?state=${encoded}`;
        navigator.clipboard.writeText(newUrl).then(() => {
            const btn = document.getElementById('btn-share');
            const originalText = btn.innerHTML;
            btn.innerHTML = "<span>‚úì Link Copied!</span>"; btn.style.backgroundColor = "#ccebc4";
            setTimeout(() => { btn.innerHTML = originalText; btn.style.backgroundColor = "white"; }, 2000);
        });
    }

    let draggedType = null;

    function dragStartNew(ev, type) { draggedType = type; ev.dataTransfer.effectAllowed = "copy"; }
    
    function copySelectedGate() {
        if(selectedIdx > -1) {
            clipboardOp = JSON.parse(JSON.stringify(circuit[selectedIdx]));
            // Capture the definition too, in case the original is deleted
            if(clipboardOp.gate === 'custom' && clipboardOp.customName && customOps[clipboardOp.customName]) {
                clipboardOp._definition = customOps[clipboardOp.customName];
            }
            popup.classList.add('hidden');
            const pasteBtn = document.getElementById('btn-paste');
            pasteBtn.innerHTML = "üìã Paste " + (clipboardOp.gate==='custom' ? clipboardOp.customName : clipboardOp.gate.toUpperCase());
            pasteBtn.classList.add('visible');
        }
    }
    function dragStartPaste(ev) { if(!clipboardOp) return; draggedType = 'paste'; ev.dataTransfer.effectAllowed = "copy"; }
    
    function dropOnSvg(ev) {
        ev.preventDefault(); 
        indicator.style.display = "none";
        if (!draggedType) return;
        
        // Reuse calculation logic
        const { qubit, index } = calculateDropTarget(ev.clientX, ev.clientY);
        pendingInsertIdx = index;

        if (draggedType === 'paste') {
            if(clipboardOp) {
                saveState(); // SAVE before paste
                const newOp = JSON.parse(JSON.stringify(clipboardOp));
                newOp.target = qubit; 
                if(newOp.control !== null && newOp.control === qubit) newOp.control = (qubit === 0) ? 1 : 0;
                
                // RESTORE DEFINITION IF MISSING
                if(newOp.gate === 'custom' && !customOps[newOp.customName] && newOp._definition) {
                    customOps[newOp.customName] = newOp._definition;
                }
                
                if (!isWithinLimit(newOp)) { showLimitModal(); draggedType=null; return; }
                circuit.splice(pendingInsertIdx, 0, newOp); finishUpdate(true);
            }
        } else if (GATE_META[draggedType]) {
            const meta = GATE_META[draggedType];
            if (meta.type === 'simple') {
                saveState(); // SAVE before simple drop
                if (!isWithinLimit({ gate: draggedType, target: qubit, control: null, target2: null })) { showLimitModal(); draggedType=null; return; }
                circuit.splice(pendingInsertIdx, 0, { gate: draggedType, target: qubit, control: null, target2: null, params: [], customName: null });
                finishUpdate(true);
            } else openModal(draggedType, -1, qubit, pendingInsertIdx);
        }
        draggedType = null;
    }
    function dragOver(ev) { ev.preventDefault(); indicator.style.display="block"; }
    function dragLeave(ev) { indicator.style.display="none"; }
    
    function showPopup(idx, mx, my) {
        selectedIdx = idx;
        const op = circuit[idx], meta = GATE_META[op.gate];
        const btnCopy = document.getElementById('btn-popup-copy'), sepCopy = document.getElementById('sep-popup-copy');
        
        // Disable copy for 2-qubit gates (control or swap types)
        if (meta.type === 'control' || meta.type === 'swap') {
             btnCopy.style.display = 'none'; 
             sepCopy.style.display = 'none';
        } else {
             btnCopy.style.display = 'block'; 
             sepCopy.style.display = 'block';
        }
        
        popup.style.left = mx + 'px'; popup.style.top = my + 'px'; popup.classList.remove('hidden');
    }
    
    function bgClick(e) { if(e.target.id === 'circuit-svg') popup.classList.add('hidden'); }
    function editSelectedGate() { if(selectedIdx > -1) { openModal(circuit[selectedIdx].gate, selectedIdx, -1); popup.classList.add('hidden'); } }
    function deleteSelectedGate() { 
        if(selectedIdx > -1) {
            saveState(); // SAVE before delete
            circuit.splice(selectedIdx, 1); 
            finishUpdate(true); 
        }
    }
    
    let editingIdx = -1, pendingGateType = '';
    
    function openModal(gateType, idx, defaultTarget, insertIdx = -1) {
        editingIdx = idx; pendingGateType = gateType; pendingInsertIdx = insertIdx;
        const meta = GATE_META[gateType], content = document.getElementById('modal-content'); content.innerHTML = '';
        const addField = (lbl, id, type='select') => {
            const div = document.createElement('div'); div.className = 'form-group';
            div.innerHTML = `<label>${lbl}</label><${type} id="${id}"></${type}>`;
            content.appendChild(div); return div.querySelector(type);
        };
        const selT = addField(gateType==='swap'?'Target Qubit 1':'Target Qubit', 'inp-target');
        for(let i=0; i<numQubits; i++) selT.add(new Option(`q[${i}]`, i));

        if (meta.type === 'control') {
            const selC = addField('Control Qubit', 'inp-control'); for(let i=0; i<numQubits; i++) selC.add(new Option(`q[${i}]`, i));
        } else if (meta.type === 'swap') {
            const selT2 = addField('Target Qubit 2', 'inp-target2'); for(let i=0; i<numQubits; i++) selT2.add(new Option(`q[${i}]`, i));
        } else if (meta.type === 'param') {
            meta.params.forEach((p, i) => { const inp = addField(`${p} (radians)`, `inp-param-${i}`, 'input'); inp.type='number'; inp.step='0.1'; inp.value='0'; });
        } else if (meta.type === 'custom') {
            const inpN = addField('Gate Name (use a valid Python variable name)', 'inp-name', 'input'); inpN.value="my_gate";
            const inpM = addField('Unitary Matrix (List of Lists)', 'inp-matrix', 'textarea'); 
            inpM.rows=4; inpM.style.fontFamily='monospace'; inpM.value='[[0, 1], [1, 0]]';
        }

        if (idx > -1) {
            const op = circuit[idx]; selT.value = op.target;
            if (meta.type === 'control') document.getElementById('inp-control').value = op.control;
            if (meta.type === 'swap') document.getElementById('inp-target2').value = op.target2;
            if (meta.type === 'param') meta.params.forEach((_, i) => document.getElementById(`inp-param-${i}`).value = op.params[i]);
            if (meta.type === 'custom') {
                document.getElementById('inp-name').value = op.customName;
                document.getElementById('inp-matrix').value = customOps[op.customName].definition;
                // document.getElementById('inp-matrix').disabled = true;  <-- REMOVED: Allow seeing, but we check conflicts on save
            }
            document.getElementById('modal-title').innerText = `Edit ${gateType.toUpperCase()}`;
        } else {
            selT.value = defaultTarget;
            if (meta.type === 'control') document.getElementById('inp-control').value = (defaultTarget===0?1:0);
            if (meta.type === 'swap') document.getElementById('inp-target2').value = (defaultTarget===0?1:0);
            document.getElementById('modal-title').innerText = `Add ${gateType.toUpperCase()}`;
        }
        document.getElementById('gate-modal').classList.add('open');
        document.getElementById('modal-error').style.display = 'none';
    }
    
    function closeModal() { document.getElementById('gate-modal').classList.remove('open'); }
    function showLimitModal() { document.getElementById('limit-modal').classList.add('open'); }
    function closeLimitModal() { document.getElementById('limit-modal').classList.remove('open'); }
    function isWithinLimit(newOp, indexToReplace = -1) {
        let temp = [...circuit]; if (indexToReplace > -1) temp.splice(indexToReplace, 1); temp.push(newOp);
        for(let i=0; i<numQubits; i++) {
            let count = 0;
            temp.forEach(op => { if (op.target === i || op.control === i || (op.gate === 'swap' && op.target2 === i)) count++; });
            if (count > MAX_GATES_PER_QUBIT) return false;
        }
        return true;
    }

    function confirmModalGate() {
        const meta = GATE_META[pendingGateType];
        const target = parseInt(document.getElementById('inp-target').value);
        let control = null, target2 = null, params = [], customName = null;

        if (meta.type === 'control') {
            control = parseInt(document.getElementById('inp-control').value);
            if(control === target) return showError("Control and Target cannot be same.");
        } else if (meta.type === 'swap') {
            target2 = parseInt(document.getElementById('inp-target2').value);
            if(target2 === target) return showError("Target qubits must be different.");
        } else if (meta.type === 'param') {
            for(let i=0; i<meta.params.length; i++) params.push(parseFloat(document.getElementById(`inp-param-${i}`).value));
        } else if (meta.type === 'custom') {
            customName = document.getElementById('inp-name').value.trim();
            if(!customName) return showError("Please provide a name.");

            // VALIDATION: Check valid Python identifier
            const validNameRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
            if (!validNameRegex.test(customName)) {
                return showError("Invalid name. Please use valid Python identifier characters (A-Z, 0-9, _) and do not start with a number.");
            }

            const RESERVED = ['h','x','y','z','s','t','rx','ry','rz','u3','cx','cz','swap','measure','reset','q','n','cudaq','labs','mz','mx','my'];
            if (RESERVED.includes(customName.toLowerCase()) || GATE_META[customName.toLowerCase()]) {
                return showError("Chose another name for your custom gate, as it is a reserved keyword or standard gate.");
            }
            
            const matrixStr = document.getElementById('inp-matrix').value.trim();
            
            // --- FIX FOR DUPLICATE NAME CONFLICTS ---
            if (customOps[customName]) {
                // If name exists, check if definition is different
                if (customOps[customName].definition !== matrixStr) {
                    // Check if we are just editing the SAME gate instance's name (which shouldn't happen here as name is key)
                    // If we are editing an existing gate, and we changed the matrix but kept the name...
                    // We must forbid this if OTHER gates use this name.
                    // Simplified policy: If name exists, definition MUST match exactly.
                    return showError(`Error: The gate name '${customName}' is already used with a different matrix definition. Please choose a unique name.`);
                }
            }
            
            // Parse and Validate Matrix
            try {
                const matrix = parseMatrix(matrixStr);
                if(!isUnitary(matrix)) {
                    return showError(`<strong>Error: Matrix is not Unitary.</strong>`);
                }
                // Only set if not already set (or if same, effectively no-op)
                if (!customOps[customName]) {
                    customOps[customName] = { matrix: matrix, definition: matrixStr };
                }
            } catch(e) { return showError("Invalid Matrix Format: " + e.message); }
        }
        
        const opData = { gate: pendingGateType, target, control, target2, params, customName };
        if (!isWithinLimit(opData, editingIdx)) { closeModal(); showLimitModal(); return; }
        
        saveState(); // SAVE before insert/edit confirmed
        
        if (editingIdx > -1) circuit[editingIdx] = opData;
        else { 
            // Handle pendingInsertIdx which might be set by drag drop or modal
            let idx = (pendingInsertIdx !== undefined && pendingInsertIdx > -1) ? pendingInsertIdx : circuit.length;
            if(idx > circuit.length) idx = circuit.length;
            circuit.splice(idx, 0, opData); 
        }
        finishUpdate(true); closeModal();
    }
    
    function showError(msg) { const d = document.getElementById('modal-error'); d.innerHTML = msg; d.style.display = 'block'; }
    
    function finishUpdate(skipSave = false) { 
        if(!skipSave) saveState();
        cleanCustomOps();
        renderCircuit(); 
        renderMeasConfig(); 
        updateCode(); 
        popup.classList.add('hidden'); 
    }
    
    function clearAll() { 
        saveState(); // SAVE before clear
        circuit = []; customOps = {}; 
        finishUpdate(true); 
    }
    
    function cleanCustomOps() {
        const used = new Set();
        circuit.forEach(op => { if(op.gate === 'custom') used.add(op.customName); });
        for (let name in customOps) {
            if (!used.has(name)) {
                delete customOps[name];
            }
        }
    }
    
    function renderCircuit() {
        svg.innerHTML = ''; 
        svg.appendChild(indicator); 
        svg.appendChild(ghost);
        
        let maxBoxWidth = 30; 
        circuit.forEach(op => { if(op.gate === 'custom') maxBoxWidth = Math.max(maxBoxWidth, 60); if(['rx','ry','rz','u3'].includes(op.gate)) maxBoxWidth = Math.max(maxBoxWidth, 70); });
        
        const spacing = (maxBoxWidth > 40) ? 80 : 60; 
        const w = Math.max(800, 100 + (circuit.length * spacing)); 
        svg.style.width = w + 'px';
        svg.style.height = '400px';
        const lineH = 400 / (numQubits + 1);
        
        for(let i=0; i<numQubits; i++) {
            const y = lineH * (i+1);
            const t = document.createElementNS("http://www.w3.org/2000/svg", "text"); 
            t.setAttribute("x", 10); t.setAttribute("y", y+5); t.textContent = `q[${i}]`; 
            t.setAttribute("style", "font-family:monospace; font-weight:bold; fill:#333; pointer-events:none;"); 
            svg.appendChild(t);
            const l = document.createElementNS("http://www.w3.org/2000/svg", "line"); 
            l.setAttribute("x1", 50); l.setAttribute("y1", y); l.setAttribute("x2", w); l.setAttribute("y2", y); l.setAttribute("class", "wire"); 
            svg.appendChild(l);
        }
        
        let x = 80;
        circuit.forEach((op, idx) => {
            const y = lineH * (op.target + 1);
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g"); 
            g.setAttribute("class", "gate-group"); 
            
            let label = GATE_META[op.gate].label, boxW = 30, isParam = false;
            if(op.gate === 'custom') { label = op.customName.substring(0,7); boxW = 60; } 
            else if (['rx','ry','rz'].includes(op.gate)) { label = op.gate.toUpperCase() + '(' + op.params[0].toFixed(2) + ')'; boxW = 75; isParam = true; }
            else if (op.gate === 'u3') { label = 'U3'; boxW = 40; isParam = true; }

            const createHitBox = (bx, by, bw, bh, isCircle=false) => {
                const hit = document.createElementNS("http://www.w3.org/2000/svg", isCircle ? "circle" : "rect"); 
                if(isCircle) { hit.setAttribute("cx", bx); hit.setAttribute("cy", by); hit.setAttribute("r", bw); } 
                else { hit.setAttribute("x", bx); hit.setAttribute("y", by); hit.setAttribute("width", bw); hit.setAttribute("height", bh); }
                hit.setAttribute("fill", "transparent"); hit.setAttribute("cursor", "pointer"); 
                hit.onclick = (e) => { e.stopPropagation(); if(draggedType !== 'move') showPopup(idx, e.clientX, e.clientY); };
                return hit;
            };

            if(op.gate === 'cx' || op.gate === 'cz') {
                const yc = lineH * (op.control + 1);
                const l = document.createElementNS("http://www.w3.org/2000/svg", "line"); l.setAttribute("x1", x); l.setAttribute("y1", y); l.setAttribute("x2", x); l.setAttribute("y2", yc); l.setAttribute("class", "control-line"); g.appendChild(l);
                const c = document.createElementNS("http://www.w3.org/2000/svg", "circle"); c.setAttribute("cx", x); c.setAttribute("cy", yc); c.setAttribute("r", 4); c.setAttribute("class", "control-dot"); g.appendChild(c);
                if(op.gate==='cx') {
                    const c2 = document.createElementNS("http://www.w3.org/2000/svg", "circle"); c2.setAttribute("cx", x); c2.setAttribute("cy", y); c2.setAttribute("r", 10); c2.setAttribute("fill", "white"); c2.setAttribute("stroke", "#333"); c2.setAttribute("stroke-width", "2"); g.appendChild(c2);
                    const v = document.createElementNS("http://www.w3.org/2000/svg", "line"); v.setAttribute("x1", x); v.setAttribute("y1", y-10); v.setAttribute("x2", x); v.setAttribute("y2", y+10); v.setAttribute("stroke", "#333"); v.setAttribute("stroke-width", "2"); g.appendChild(v);
                    const h = document.createElementNS("http://www.w3.org/2000/svg", "line"); h.setAttribute("x1", x-10); h.setAttribute("y1", y); h.setAttribute("x2", x+10); h.setAttribute("y2", y); h.setAttribute("stroke", "#333"); h.setAttribute("stroke-width", "2"); g.appendChild(h);
                    g.appendChild(createHitBox(x, y, 12, 0, true));
                } else {
                    const c2 = document.createElementNS("http://www.w3.org/2000/svg", "circle"); c2.setAttribute("cx", x); c2.setAttribute("cy", y); c2.setAttribute("r", 4); c2.setAttribute("class", "control-dot"); g.appendChild(c2);
                    g.appendChild(createHitBox(x, y, 8, 0, true));
                }
                g.appendChild(createHitBox(x, yc, 8, 0, true));
            } else if (op.gate === 'swap') {
                const y2 = lineH * (op.target2 + 1);
                const l = document.createElementNS("http://www.w3.org/2000/svg", "line"); l.setAttribute("x1", x); l.setAttribute("y1", y); l.setAttribute("x2", x); l.setAttribute("y2", y2); l.setAttribute("class", "control-line"); g.appendChild(l);
                [y, y2].forEach(yp => { 
                    const txt = document.createElementNS("http://www.w3.org/2000/svg", "text"); 
                    txt.setAttribute("x", x); txt.setAttribute("y", yp+4); txt.setAttribute("text-anchor", "middle"); txt.textContent = "√ó"; txt.setAttribute("font-size", "20"); txt.setAttribute("font-weight", "bold"); txt.setAttribute("pointer-events", "none"); g.appendChild(txt); 
                    g.appendChild(createHitBox(x-10, yp-10, 20, 20));
                });
            } else {
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect"); 
                rect.setAttribute("x", x - (boxW/2)); rect.setAttribute("y", y-15); rect.setAttribute("width", boxW); rect.setAttribute("height", 30);
                if (isParam) rect.setAttribute("class", "gate-box param"); else rect.setAttribute("class", "gate-box"); 
                g.appendChild(rect);
                const txt = document.createElementNS("http://www.w3.org/2000/svg", "text"); 
                txt.setAttribute("x", x); txt.setAttribute("y", y+4); txt.setAttribute("text-anchor", "middle");
                if (isParam) txt.setAttribute("class", "gate-text param"); else txt.setAttribute("class", "gate-text"); 
                txt.textContent = label; txt.setAttribute("pointer-events", "none"); 
                g.appendChild(txt);
                g.appendChild(createHitBox(x - (boxW/2), y-15, boxW, 30));
            }
            svg.appendChild(g); x += spacing;
        });
    }

    class Complex { constructor(r,i){this.re=r;this.im=i} add(c){return new Complex(this.re+c.re,this.im+c.im)} sub(c){return new Complex(this.re-c.re,this.im-c.im)} mul(c){return new Complex(this.re*c.re-this.im*c.im,this.re*c.im+this.im*c.re)} magSq(){return this.re**2+this.im**2} toString(){const r=Math.abs(this.re)<1e-10?0:this.re, i=Math.abs(this.im)<1e-10?0:this.im; return i===0?r.toFixed(3):`${r.toFixed(3)}${i>=0?'+':''}${i.toFixed(3)}j`} }
    const C0=new Complex(0,0), C1=new Complex(1,0), C_INV2=new Complex(1/Math.sqrt(2),0), CN_INV2=new Complex(-1/Math.sqrt(2),0);
    const SIM_OPS = {
        h:()=>[[C_INV2,C_INV2],[C_INV2,CN_INV2]], x:()=>[[C0,C1],[C1,C0]], y:()=>[[C0,new Complex(0,-1)],[new Complex(0,1),C0]], z:()=>[[C1,C0],[C0,new Complex(-1,0)]],
        s:()=>[[C1,C0],[C0,new Complex(0,1)]], t:()=>[[C1,C0],[C0,new Complex(Math.cos(Math.PI/4),Math.sin(Math.PI/4))]],
        rx:(p)=>{const t=p[0]/2; return [[new Complex(Math.cos(t),0),new Complex(0,-Math.sin(t))],[new Complex(0,-Math.sin(t)),new Complex(Math.cos(t),0)]]},
        ry:(p)=>{const t=p[0]/2; return [[new Complex(Math.cos(t),0),new Complex(-Math.sin(t),0)],[new Complex(Math.sin(t),0),new Complex(Math.cos(t),0)]]},
        rz:(p)=>{const t=p[0]/2; return [[new Complex(Math.cos(t),-Math.sin(t)),C0],[C0,new Complex(Math.cos(t),Math.sin(t))]]},
        u3:(p)=>{const [t,ph,lam]=p, c=Math.cos(t/2), s=Math.sin(t/2); return [[new Complex(c,0),new Complex(Math.cos(lam),Math.sin(lam)).mul(new Complex(-s,0))],[new Complex(Math.cos(ph),Math.sin(ph)).mul(new Complex(s,0)),new Complex(Math.cos(ph+lam),Math.sin(ph+lam)).mul(new Complex(c,0))]]}
    };
    function applyOneQubit(s, dim, t, m) { const ns=new Array(dim).fill(null).map(_=>C0); for(let i=0;i<dim;i++){if(s[i].magSq()<1e-15)continue; const one=(i>>t)&1, p=i^(1<<t); if(!one){ns[i]=ns[i].add(s[i].mul(m[0][0]));ns[p]=ns[p].add(s[i].mul(m[1][0]));}else{ns[p]=ns[p].add(s[i].mul(m[0][1]));ns[i]=ns[i].add(s[i].mul(m[1][1]));}} return ns; }
    function applyControlled(s, dim, c, t, m) { const ns=new Array(dim).fill(null).map(_=>C0); for(let i=0;i<dim;i++){if(s[i].magSq()<1e-15)continue; if(!((i>>c)&1)){ns[i]=ns[i].add(s[i]);continue;} const one=(i>>t)&1, p=i^(1<<t); if(!one){ns[i]=ns[i].add(s[i].mul(m[0][0]));ns[p]=ns[p].add(s[i].mul(m[1][0]));}else{ns[p]=ns[p].add(s[i].mul(m[0][1]));ns[i]=ns[i].add(s[i].mul(m[1][1]));}} return ns; }
    function applySwap(s, dim, q1, q2) { const ns=new Array(dim).fill(null).map(_=>C0); for(let i=0;i<dim;i++){if(s[i].magSq()<1e-15)continue; const b1=(i>>q1)&1, b2=(i>>q2)&1; if(b1===b2)ns[i]=ns[i].add(s[i]); else{let j=i^(1<<q1)^(1<<q2); ns[j]=ns[j].add(s[i]);}} return ns; }
    function executeCircuit() {
        const dim=1<<numQubits; let state=new Array(dim).fill(null).map(_=>C0); state[0]=C1;
        try { circuit.forEach(op => {
            if(op.gate==='swap') state=applySwap(state,dim,op.target,op.target2);
            else {
                let m; if(op.gate==='custom') m=customOps[op.customName].matrix; else if(SIM_OPS[op.gate]) m=SIM_OPS[op.gate](op.params);
                if(op.gate==='cx') state=applyControlled(state,dim,op.control,op.target,[[C0,C1],[C1,C0]]);
                else if(op.gate==='cz') state=applyControlled(state,dim,op.control,op.target,[[C1,C0],[C0,new Complex(-1,0)]]);
                else if(op.gate!=='swap') state=applyOneQubit(state,dim,op.target,m);
            }
        }); } catch(e) { alert("Error: "+e.message); return; }
        if (execMode === 'run') { for(let i=0; i<numQubits; i++) { if(measurements[i]==='mx') state=applyOneQubit(state,dim,i,SIM_OPS['h']()); else if(measurements[i]==='my') { state=applyOneQubit(state,dim,i,[[C1,C0],[C0,new Complex(0,-1)]]); state=applyOneQubit(state,dim,i,SIM_OPS['h']()); } }}
        displayResults(state, dim);
    }
    function displayResults(state, dim) {
        const tc = document.getElementById('table-container'), cw = document.getElementById('chart-wrapper'), cc = document.getElementById('chart-canvas'), rc = document.getElementById('raw-container');
        cw.style.display = 'none'; rc.style.display = 'none'; if(window.myChart) window.myChart.destroy();
        if (execMode === 'state') {
            let html = `<table class="result-table"><thead><tr><th>State</th><th>Amplitude</th><th>Probability</th></tr></thead><tbody>`;
            let labels = [], data = [];
            for(let i=0; i<dim; i++) {
                const p = state[i].magSq();
                if (p > 0.0001) {
                    const bin = i.toString(2).padStart(numQubits,'0').split('').reverse().join('');
                    html += `<tr><td>|${bin}‚ü©</td><td>${state[i].toString()}</td><td>${p.toFixed(4)}</td></tr>`;
                    labels.push(`|${bin}‚ü©`); data.push(p);
                }
            }
            html += "</tbody></table>"; tc.innerHTML = html; cw.style.display = 'block';
            window.myChart = new Chart(cc, { type: 'bar', data: { labels, datasets: [{ label: 'Probability', data, backgroundColor: '#76b900' }] } });
        } else if (execMode === 'sample') {
            let counts = {}; let probs = [], sum = 0; for(let i=0; i<dim; i++) { sum += state[i].magSq(); probs.push(sum); }
            for(let k=0; k<1000; k++) { let r = Math.random(), outcome = 0; for(let i=0; i<dim; i++) { if(r <= probs[i]) { outcome = i; break; } } const bin = outcome.toString(2).padStart(numQubits,'0').split('').reverse().join(''); counts[bin] = (counts[bin] || 0) + 1; }
            let html = `<table class="result-table"><thead><tr><th>State</th><th>Count (1000 shots)</th></tr></thead><tbody>`;
            const sortedKeys = Object.keys(counts).sort(); sortedKeys.forEach(k => { html += `<tr><td>|${k}‚ü©</td><td>${counts[k]}</td></tr>`; });
            html += "</tbody></table>"; tc.innerHTML = html; cw.style.display = 'block';
            window.myChart = new Chart(cc, { type: 'bar', data: { labels: sortedKeys, datasets: [{ label: 'Counts', data: sortedKeys.map(k=>counts[k]), backgroundColor: '#76b900' }] } });
        } else if (execMode === 'run') {
            let activeIndices = []; for(let i=0; i<numQubits; i++) if(measurements[i] !== 'none') activeIndices.push(i);
            if (activeIndices.length === 0) { tc.innerHTML = "<em>No measurements selected.</em>"; return; }
            let probs = [], sum = 0; for(let i=0; i<dim; i++) { sum += state[i].magSq(); probs.push(sum); }
            let results = [];
            for(let s=0; s<20; s++) {
                let r = Math.random(), outcome = 0; for(let i=0; i<dim; i++) { if(r <= probs[i]) { outcome = i; break; } }
                if(activeIndices.length === 1) results.push(((outcome >> activeIndices[0]) & 1) === 1);
                else results.push(activeIndices.map(idx => ((outcome >> idx) & 1) === 1));
            }
            const counts = {}; results.forEach(res => { const k = Array.isArray(res) ? JSON.stringify(res).replace(/true/g,"True").replace(/false/g,"False") : (res ? "True" : "False"); counts[k] = (counts[k] || 0) + 1; });
            let html = `<div style="font-weight:bold; margin-bottom:5px;">Counts (20 Shots)</div><table class="result-table"><thead><tr><th>Result (1=True)</th><th>Count</th></tr></thead><tbody>`;
            for(const [r, c] of Object.entries(counts)) html += `<tr><td>${r}</td><td>${c}</td></tr>`;
            tc.innerHTML = html + "</tbody></table>"; rc.style.display = 'block'; document.getElementById('raw-text').innerText = JSON.stringify(results).replace(/true/g, "True").replace(/false/g, "False");
        }
    }

    function parseMatrix(str) { 
        try { 
            let cleanStr=str.replace(/j/g, 'i'); 
            const arr=math.evaluate(cleanStr);
            let rows, cols;
            if (arr.size) { const s = arr.size(); rows = s[0]; cols = s[1]; } 
            else if (Array.isArray(arr)) { rows = arr.length; cols = Array.isArray(arr[0]) ? arr[0].length : 0; }
            if (rows !== 2 || cols !== 2) throw new Error("Matrix must be exactly 2x2 for this browser simulation. Larger matrices are supported in CUDA-Q.");
            const res=[[],[]]; 
            for(let r=0;r<2;r++) for(let c=0;c<2;c++) { 
                const v=arr.get ? arr.get([r,c]) : arr[r][c];
                res[r][c]=(typeof v==='number')?new Complex(v,0):new Complex(v.re,v.im); 
            } 
            return res; 
        } catch(e) { throw new Error(e.message || "Syntax error. Use format [[1,0],[0,1]]"); } 
    }

    function isUnitary(m) { const a=m[0][0], b=m[0][1], c=m[1][0], d=m[1][1]; const r1=a.magSq()+b.magSq(), r2=c.magSq()+d.magSq(); const cross=a.mul(new Complex(c.re,-c.im)).add(b.mul(new Complex(d.re,-d.im))).magSq(); return Math.abs(r1-1)<1e-4 && Math.abs(r2-1)<1e-4 && cross<1e-4; }
</script>
</body>
</html>